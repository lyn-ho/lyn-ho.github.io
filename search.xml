<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【译】JavaScript 工作原理：V8 引擎中5个优化代码的技巧</title>
      <link href="/2018/09/15/trans-9/"/>
      <url>/2018/09/15/trans-9/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a></p></blockquote><p>几个星期之前，我们开始了一个旨在深入挖掘 JavaScript 及其实际工作原理的系列文章，我们认为，通过了解 JavaScript 的底层构建以及它们是如何协作的，你将能够编写更好的代码和应用。</p><p><a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">第一篇文章</a>主要关注引擎，运行时和调用栈的概述。 第二篇文章将深入探讨 Google’s V8 引擎内部。我们还提供了一些关于如何编写更好的 JavaScript 代码的快速提示 —— 我们 <a href="https://www.sessionstack.com/" target="_blank" rel="noopener">SessionStack</a> 开发团队在构建产品时  遵循的最佳实践。</p><h2 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述 (Overview)"></a>概述 (Overview)</h2><p><strong>JavaScript 引擎</strong>是一个可以执行 JavaScript 代码的程序或解释器。 JavaScript 引擎可以是标准实现解释器或者是可以以某种方式实现编译 JavaScript 为字节码的即时编译器。</p><a id="more"></a><p>下面是流行 JavaScript 引擎列表：</p><ul><li><p><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="noopener"><strong>V8</strong></a> —— 开源， Google 开发， C++ 编写</p></li><li><p><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="noopener"><strong>Rhino</strong></a> —— Mozilla 基金会管理，开源，全 Java 开发</p></li><li><p><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="noopener"><strong>SpiderMonkey</strong></a> —— 第一个 JavaScript 引擎，当时支持 Netscape Navigator ， 现在支持 FireFox</p></li><li><p><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="noopener"><strong>JavaScriptCore</strong></a> —— 开源， Apple 公司 为 Safari 浏览器开发并以 Nitro 为名字推广</p></li><li><p><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="noopener"><strong>KJS</strong></a> ——  KDE 的引擎，最初是由 Harri Porten 为 KDE 项目的 Konqueror 网络浏览器开发</p></li><li><p><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="noopener"><strong>Chakra</strong> (JScript9)</a> —— Internet Explorer</p></li><li><p><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="noopener"><strong>Chakra</strong> (JavaScript)</a> —— Microsoft Edge</p></li><li><p><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="noopener"><strong>Nashorn</strong></a> —— 开源，由 Oracle 的 Java 语言工具组开发，是 OpenJDK 的一部分</p></li><li><p><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="noopener"><strong>JerryScript</strong></a> —— 物联网轻量级引擎</p></li></ul><h2 id="为什么创建了-V8-引擎"><a href="#为什么创建了-V8-引擎" class="headerlink" title="为什么创建了 V8 引擎"></a>为什么创建了 V8 引擎</h2><p>V8 引擎是由 Google 开发 C++ 编写的开源引擎。它被用于 Google Chrome 。但是，和其他引擎不一样，V8 也被用于 Node.js runtime 。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*AKKvE3QmN_ZQmEzSj16oXg.png" alt="V8"></p><p>V8 最初是为了提高 Web 浏览器中 JavaScript 执行的性能。为了获得更快的速度，V8 将 JavaScript 转换为更高效的机器码，而不是使用解释器。它像 SpiderMonkey 或者 Rhino (Mozilla) 等很多现代 JavaScript 引擎一样，通过 <strong>JIT(Just-In-Time)编译器</strong> 将 JavaScript 代码编译成机器码。区别是 V8 不生成字节码或任何中间代码。</p><h2 id="V8-曾经有两个编译器"><a href="#V8-曾经有两个编译器" class="headerlink" title="V8 曾经有两个编译器"></a>V8 曾经有两个编译器</h2><p>在 V8 的 v5.9 版本出来之前，它曾经拥有两个  编译器：</p><ul><li><p>full-codegen —— 一个简单且快速的编译器，可以生成简单但相对  较慢的机器码。</p></li><li><p>Grankshaft —— 一个较复杂的即时优化编译器，可以生成  高度优化的代码</p></li></ul><p>V8 引擎内部使用了多线程：</p><ul><li><p>主线程完成你所期望的任务：获取你的代码，编译执行</p></li><li><p>还有一个单独的线程用于编译，以便主线程可以继续执行，而前者可以优化代码</p></li><li><p>Profiler 线程，它将通知  运行时  哪些  方法花费大量时间，以便 Crankshaft 可以优化它们</p></li><li><p> 少许线程来处理垃圾收集器扫描</p></li></ul><p>首次执行 JavaScript 代码，V8 利用 <strong>full-codegen</strong> 直接将解析后的 JavaScript 不经任何转换地编译为机器码。这使它可以非常快速地  开始执行机器码。注意， V8 不使用中间字节码，因此不需要解释器。</p><p>当代码运行一段时间后， profiler 线程以及收集来足够的数据来通知运行时应该优化哪个方法。</p><p>然后， <strong>Crankshaft</strong> 在另一个线程开始优化。它将 JavaScript 抽象语法树转换为名为 <strong>Hydrogen</strong> 的高级静态单元分配表示 (SSA) ，并尝试去优化这个 Hydrogen 图。大多数优化在这个层级完成。</p><h2 id="代码嵌入-Inlining"><a href="#代码嵌入-Inlining" class="headerlink" title="代码嵌入 (Inlining)"></a>代码嵌入 (Inlining)</h2><p>首次优化是尽可能的提前嵌入更多的代码。代码嵌入就是将使用函数的地方( 函数被调用的那一行代码)替换成调用函数的本体。这个简单的步骤使下面的优化更有意义。</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*RRgTDdRfLGEhuR7U.png" alt="inlining"></p><h2 id="隐藏类-Hidden-class"><a href="#隐藏类-Hidden-class" class="headerlink" title="隐藏类 (Hidden class)"></a>隐藏类 (Hidden class)</h2><p>JavaScript 是一门基于原型的语言：没有通过克隆创建的类和对象。 JavaScript 也是一门动态语言，这意味着可以在对象实例化后轻易地向它添加或删除属性。</p><p> 大多数 JavaScript 解释器使用类似字典的结构 (基于<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">散列函数</a>) 来存储对象属性在内存中的位置。这种结构使得在 JavaScript 中检索属性的值比在 Java 或 C＃ 等非动态编程语言中的计算成本更高。在 Java 中，所有对象属性都是在编译之前由固定对象布局确定的，并且无法在运行时动态添加或删除 (C＃具有 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic" target="_blank" rel="noopener">动态类型</a>，这是另一个主题) 。因此，属性值（或指向这些属性的指针）可以作为连续 buffer 存储在存储器中，每个值之间具有固定偏移值。可以根据属性类型轻易确定偏移的长度，而在运行时可以更改属性类型的 JavaScript 中，这是不可能的。</p><p>由于使用字典在内存中查找对象属性的位置效率非常低，因此 V8 使用不同的方法：<strong>隐藏类 (hidden classes)</strong> 。隐藏类的工作方式类似于 Java 等语言中使用的固定对象布局（类），除了它们是在运行时创建的。现在，让我们看看它们实际上是什么样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一旦 <code>new Point(1, 2)</code> 被调用，V8 会生成一个 <code>C0</code> 的隐藏类。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*pVnIrMZiB9iAz5sW28AixA.png" alt="C0"></p><p>到现在还没有为 <code>Point</code> 定义任何属性，所以 <code>C0</code> 是空的。</p><p> 一旦第一条语句 <code>this.x = x</code> (<code>Point</code> 函数内的) 执行后，V8 将创建一个基于 <code>C0</code> 的第二个隐藏类 <code>C1</code> 。<code>C1</code> 描述了属性值 <code>x</code> 在内存中的位置(相对于对象指针) 。在这个例子中，<code>x</code> 存储在<a href="">偏移值</a>为 0 的地方，这意味着当在内存中把 <code>point</code> 对象视为一段连续的 buffer 时，它的第一偏移量对应的属性就是 <code>x</code> 。V8  还会使用 “ 类转换 (class transition)” 更新 <code>C0</code> ，如果将属性 <code>x</code> 添加到 <code>Point</code> 对象， 隐藏类就会从 <code>C0</code> 切换到 <code>C1</code> 。现在 <code>Point</code> 对象的隐藏类为 <code>C1</code> 。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*QsVUE3snZD9abYXccg6Sgw.png" alt="C1"></p><p>每当一个新属性添加到对象，旧的隐藏类就会通过一个转换路径更新成一个新的隐藏类。隐藏类转换非常重要，因为它们允许在以相同方式创建的对象之间共享隐藏类。如果两个对象共享一个隐藏类，并给它们添加相同的属性，隐藏类转换能够确保这两个对象都获得新的隐藏类以及与之相关联的优化代码。</p><p>当执行语句 <code>this.y = y</code> (同样，在 <code>Point</code> 函数内部，<code>this.x = x</code> 语句之后) 时，将重复此过程。</p><p>一个新的隐藏类 <code>C2</code> 被创建了，如果属性 <code>y</code> 被添加到 Point 对象(已经包含了 <code>x</code> 属性)，同样的过程，类型转换被添加到 <code>C1</code> 上，然后隐藏类开始更新成 <code>C2</code>，并且 Point 对象的隐藏类就要更新成 <code>C2</code> 了。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/18/15fcec13180b6f2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="C2"></p><p>隐藏类转换是根据属性被添加到对象上的顺序而发生变化。我们看看下面这一小段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p1.a = <span class="number">5</span></span><br><span class="line">p1.b = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p2.b = <span class="number">7</span></span><br><span class="line">p2.a = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>现在，你可能认为 <code>p1</code> 和 <code>p2</code> 使用了相同的隐藏类和类转换。其实不然，对于 <code>p1</code> 先添加属性 <code>a</code> 再添加属性 <code>b</code> ，但是 <code>p2</code> 先添加 <code>b</code> 后添加 <code>a</code> 。因此，<code>p1</code> 和 <code>p2</code> 以不同转换路径的结束，它们的隐藏类也不同。<strong>在这种情况下， 最好以相同的顺序初始化动态属性，以便可以复用隐藏类。</strong></p><h2 id="内联缓存-Inline-caching"><a href="#内联缓存-Inline-caching" class="headerlink" title="内联缓存 (Inline caching)"></a>内联缓存 (Inline caching)</h2><p>V8 利用另一种被称为内联缓存的技术来优化动态类型语言。内联缓存依赖于观察到：发生在相同类型的对象上的同一个方法的重复调用。关于内联缓存深入解释请看<a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="noopener">这里</a>。</p><p>我们将讨论内联缓存的一般概念（如果您没有时间进行上面的深入解释）。</p><p>那么它是怎样工作的？V8 会维护一个在最近的方法调用的参数的对象类型的缓存，并使用这些信息去预测将要传入参数的对象类型。如果 V8 对传递给方法的对象类型做出了很好的预测，那么它就能够绕开获取对象属性的计算过程，取而代之的是使用先前查找这个对象的隐藏类时所存储的信息。</p><p>那么隐藏类和内联缓存的概念是如何  关联的？每当在特定对象上调用方法时，V8 引擎必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，，V8 就会略过查找隐藏类，将这个属性的偏移值添加到对象本身的指针上。未来这个方法的所有调用，V8 引擎都会假设隐藏类没有更改，并使用先前查找中存储的偏移  值直接跳转到特定属性的内存地址。这极大的提高了 V8 的执行速度。</p><p>内联缓存也是同类型对象共享隐藏类非常重要的原因。如果创建两个相同类型且具有不同隐藏类的对象(如同我们之前的示例)，V8 将无法使用内联缓存，因为即使两个对象属于同一类型，其对应的隐藏类也会为其属性分配不同的偏移值。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*iHfI6MQ-YKQvWvo51J-P0w.png" alt="inline caching"></p><p>这两个对象基本相同，但 <code>a</code> 和 <code>b</code> 属性的创建顺序不同。</p><h2 id="编译成机器码-Compilation-to-machine-code"><a href="#编译成机器码-Compilation-to-machine-code" class="headerlink" title="编译成机器码 (Compilation to machine code)"></a>编译成机器码 (Compilation to machine code)</h2><p>经 Hydrogen graph 优化后，Crankshaft 将其降低到一个较低层次 Lithium 。大多数 Lithium 实现都是特定于体系结构的。寄存器分配发生在这个级别。</p><p>最后， Lithium 会被编译成机器码。然后，触发 OSR 一种运行时替换正在运行的栈帧的技术 (on-stack replacement) 。这我们开始编译和优化一个明显耗时的方法之前，我们可能正在运行它。V8 不会  遗弃  正在缓慢执行的代码而直接开始执行优化  后的。相反，它将转换所有的上下文环境 (堆栈，寄存器) ，以便我们可以这执行过程中切换到优化的版本。这是一项非常复杂的任务，请记住，在其他优化中，V8 原来已经内联了代码。V8 并不是唯一能够做到这一点的引擎。</p><p>V8 有一种称为去优化的保护措施可以进行相反的转换，并在发动机制造的假设不再适用的情况下恢复到非优化代码。</p><h2 id="垃圾回收-Garbage-collection"><a href="#垃圾回收-Garbage-collection" class="headerlink" title="垃圾回收 (Garbage collection)"></a>垃圾回收 (Garbage collection)</h2><p>对于垃圾收集，V8 采用传统的标记和扫描方式来清理旧数据。标记阶段会阻止 JavaScript 执行。为了控制 GC 成本并使运行更稳定，V8 使用增量标记：不是遍历整个堆，尝试标记每个可能的对象，它只是遍历堆的一部分，然后恢复正常执行。下一个 GC 将从上一个堆遍历停止的位置继续。这允许在正常执行期间非常短暂的暂停。如前所述，扫描阶段由单独的线程处理。</p><h2 id="Ignition-和-TurboFan"><a href="#Ignition-和-TurboFan" class="headerlink" title="Ignition 和 TurboFan"></a>Ignition 和 TurboFan</h2><p>随着 2017 年早些时候发布 V8 v5.9，引入了新的执行管道。这个新的管道在实际的 JavaScript 应用程序中实现了更大的性能提升和显着的内存节省。</p><p>新的执行管道建立在 V8 解释器 <a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="noopener">Ignition</a>，和最新优化的 V8 编译器 <a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="noopener">TurboFan</a> 之上。</p><p>您可以在<a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">这里</a>查看 V8 团队关于该主题的博客文章。</p><p>自从 V8 的 v5.9 版本问世以来，V8 已经不再使用 full-codegen 和 Crankshaft（自 2010 年以来为 V8 提供服务的技术）用于执行 JavaScript，因为 V8 团队一直在努力跟上新的 JavaScript 语言功能以及功能优化。</p><p>这意味着整体 V8 将具有更简单，更易维护的架构。</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*pohqKvj9psTPRlOv.png" alt="Improvements on Web and Node.js benchmarks"></p><p>这些改进只是一个开始。新的 Ignition 和 TurboFan 管道为进一步优化铺平了道路，这些优化将在未来几年内提升 JavaScript 性能并缩小 V8 在 Chrome 和 Node.js 中的占用空间。</p><p>最后，这里有一些关于如何编写优化良好的 JavaScript 的技巧和窍门。您可以从上面的内容中轻松地推导出这些内容，但是，这里是为方便起见的摘要：</p><h2 id="如何编写优化的-JavaScript"><a href="#如何编写优化的-JavaScript" class="headerlink" title="如何编写优化的 JavaScript"></a>如何编写优化的 JavaScript</h2><ol><li><p><strong>对象属性的顺序</strong> ：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。</p></li><li><p><strong>动态属性</strong> ：在向实例化的对象添加属性将强制更改隐藏类并减慢为先前隐藏类优化的任何方法。而是在其构造函数中分配所有对象的属性。</p></li><li><p><strong>方法</strong> ：重复执行相同方法的代码将比仅执行一次许多不同方法的代码运行得更快（因为内联缓存）。</p></li><li><p><strong> 数组</strong> ：避免 keys 不是增量数字的稀疏数组。含有空元素的稀疏数组是<strong>哈希表</strong>。这种数组中的元素访问起来更加昂贵。另外，尽量避免预先分配大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素。它使 keys 稀疏。</p></li><li><p><strong>标记值</strong> ：V8 使用 32 位表示对象和数字。它使用一个位来知道它是一个对象（flag = 1）还是一个称为 SMI（SMall Integer）的整数（flag = 0），因为它是 31 位的。然后，如果数值大于 31 位，V8 将对该数字进行  封装 (box) ，将其变为双精度 (double) 并创建一个新对象以将数字放入其中。尽可能使用 31 位带符号的数字，以避免对 JS 对象进行昂贵的装箱操作。尽可能使用 31 位带符号的数字，以避免对 JS 对象进行昂贵的封装操作。</p></li></ol><h2 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源 (Resources)"></a>资源 (Resources)</h2><ul><li><p><a href="https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub" target="_blank" rel="noopener">Crankshafting from the ground up</a></p></li><li><p><a href="https://github.com/thlorenz/v8-perf" target="_blank" rel="noopener">Notes and resources related to V8 and thus Node.js performance</a></p></li><li><p><a href="https://bugs.chromium.org/p/v8/adminIntro" target="_blank" rel="noopener">Project: v8</a></p></li><li><p><a href="https://mrale.ph/v8/resources.html" target="_blank" rel="noopener">V8 Resources</a></p></li><li><p><a href="https://www.youtube.com/watch?v=UJPdhx5zTaw" target="_blank" rel="noopener">Google I/O 2012 - Breaking the JavaScript Speed Limit with V8</a></p></li><li><p><a href="https://www.youtube.com/watch?v=hWhMKalEicY" target="_blank" rel="noopener">V8: an open source JavaScript engine</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是函数组合（Function Composition）？</title>
      <link href="/2018/09/10/trans-7/"/>
      <url>/2018/09/10/trans-7/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">Master the JavaScript Interview: What is Function Composition?</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*4trMikhKRHhSUlI2D6h_mA.jpeg" alt="Google Datacenter Pipes — Jorge Jorquera — (CC-BY-NC-ND-2.0)"></p><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><p>函数式编程已经成为了 JavaScript 世界的一个热门话题。仅仅在几年前，甚至只有很少 JavaScript 开发者知道函数式编程，但是在过去的3年中我看到了大量使用函数式编程思维构建的应用。</p><p>函数组合是将两个或多个函数组合以产生新函数的过程。将函数组合在一起就像是将一系列管道拼凑在一起，以便我们的数据流过。</p><a id="more"></a><p>简而言之，函数 <code>f</code> 和 <code>g</code> 的组合可以定义为 <code>f(g(x))</code> ，它从内到外，从右到左进行求值。换句话说，求值顺序是：</p><ol><li><p><code>x</code></p></li><li><p><code>g</code></p></li><li><p><code>f</code></p></li></ol><p>让我们在代码中进一步观察这个概念。想象一下，你希望将用户的全名转换为 URL slugs ，以便为每个用户提供一个 profile 页面。为了实现这一点，你需要完成一系列的步骤：</p><ol><li><p>将姓名以空格拆分到一个数组中</p></li><li><p>将名字映射为小写</p></li><li><p>用破折号 <code>-</code> 链接数组中的名字</p></li><li><p>编码为 URI component</p></li></ol><p>下面是一个简单的实现：</p><script src="//gist.github.com/abc20e52b727ad246be4afe8dcf21f16.js?file=toSlug.js"></script><p>还不错，但如果我告诉你让它更具可读性呢？</p><p>想象一下，每个操作都对应一个可组合的函数。它可以写成这样：</p><script src="//gist.github.com/ad816466c9540132b59561b56cb7720f.js?file=nesting-composition.js"></script><p>这看起来比我们的第一次尝试更难阅读，但先忍一下，我们就要解决了。</p><p>为了实现这一点，我们使用可组合形式的常用工具函数，例如 <code>split()</code> <code>join()</code> 和 <code>map()</code> 。下面是它们的实现：</p><script src="//gist.github.com/a51511a34c803c758422ed4e5fcd2efe.js?file=composables.js"></script><p>除了 <code>toLowerCase()</code> 之外，这些函数都可以从 Lodash/fp 获得。你可以像这样导入它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; curry, map, join, split &#125; <span class="keyword">from</span> <span class="string">'lodash/fp'</span></span><br></pre></td></tr></table></figure><p>或者像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="built_in">require</span>(<span class="string">'lodash/fp/curry'</span>)</span><br><span class="line"><span class="keyword">const</span> map = <span class="built_in">require</span>(<span class="string">'lodash/fp/map'</span>)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这我偷懒了。注意这个 curry 不是真正的技术上的柯里化函数，真正的柯里化函数总是产生一元函数。这里的 curry 只是一个简单的偏函数应用。参考 <a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8" target="_blank" rel="noopener"> “What’s the Difference Between Curry and Partial Application?”</a> ,但是为了这次演示的目的，将它作为真正的柯里化函数。</p><p>回头看我们的 <code>toSlug()</code> 的实现，有一些东西真的困扰了我：</p><script src="//gist.github.com/ad816466c9540132b59561b56cb7720f.js?file=nesting-composition.js"></script><p>在我看来它似乎有很深的嵌套，读起来有点混乱。我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获得输出并自动传入到下一个函数的输入，直到输出最终值。</p><p>想想看，好像数组中有一个函数可以做到差不多的事情。这个函数就是 <code>reduce()</code> ，它拿到一个值的列表并对这每个值应用一个函数，累计得出一个结果。这些值可以是函数。但是为了和上面的行为组合相匹配，我们需要 <code>reduce()</code> 从右向左递减而不是从左到右递减。</p><p>好事情是有一个 <code>reduceRight()</code> 函数做到了我们需要的事情：</p><script src="//gist.github.com/fce3416828f389618623fcfcef387756.js?file=compose.js"></script><p>和 <code>.reduce()</code> 一样， <code>.reduceRight()</code> 方法也有一个 reducer 函数和初始值 <code>x</code> 。我们从右向左迭代数组中的函数，依次将每个函数应用后的值累计到最终值 <code>v</code> 。</p><p>使用 compose ， 我们可以不使用嵌套来重写上面的组合函数：</p><script src="//gist.github.com/e9c02710a62e68683b6aa38d7729408f.js?file=using-compose.js"></script><p>当然， <code>compose()</code> 在 lodash/fp 中也有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compose &#125; <span class="keyword">from</span> <span class="string">'lodash/fp'</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">'lodash/fp/compose'</span>)</span><br></pre></td></tr></table></figure><p>当以数学形式从内到外的角度思考时， compose 是很棒的，但是如果你想从左到右顺序的角度来思考，该如何去做？</p><p>通常还有另外一种方式称作 <code>pipe()</code> 。在 Lodash 中称作 <code>flow()</code> 。</p><script src="//gist.github.com/8287dd95e9d7be38e9c33a948dfc63e2.js?file=pipe.js"></script><p>注意，<code>pipe()</code> 和 <code>compose()</code> 的实现完全相同，除了使用了 <code>.reduce()</code> 而不是 <code>.reduceRight()</code> ，即是从左到右缩减而不是从右到左。</p><p>让我们看看用 <code>pipe()</code> 实现的 <code>toSlug()</code> 函数：</p><script src="//gist.github.com/c0ce31c7534a5b693c32547877aac2ac.js?file=using-pipe.js"></script><p>这对我来说更易阅读。</p><p>硬核函数式程序员使用函数组合定义他们的整个应用程序。我经常使用它来消除对临时变量的需求。仔细观察 <code>pipe()</code> 版本的 <code>toSlug()</code> 函数，你可能会注意到一些特别的事情。</p><p>在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面 <code>pipe()</code> 的实现是以 <strong>无参(points-free)</strong> 风格的方式编写，这意味着它根本不识别它运行的参数。</p><p>我经常在单元测试和 Redux state reducers 之类的实现中使用 pipes 来消除对中间变量的需求，这些中间变量仅存于一个操作和下一个操作之间的瞬间值。</p><p>这听起来可能很奇怪，但是随着你使用它，你会发现在函数式编程中，你是在和相当抽象广义的函数打交道，其中事物的名称并不重要。名称只是妨碍。你可能开始将变量视为不必要的样板。</p><p>也就是说，我认为无参风格可能被过度使用。它可能变得过于密集，难以理解，但是如果你感到困惑，这里有一个小小的建议，你可以进入流程来跟踪发生了什么：</p><script src="//gist.github.com/6f354876134011f0fbcb1355ce9da6f4.js?file=trace.js"></script><p>下面如何使用它：</p><script src="//gist.github.com/16fd8336b32ab0ec71e6c4be61ce355f.js?file=using-trace.js"></script><p><code>trace()</code> 只是更通用的 <code>tap()</code> 的一种特殊形式，它允许你为流经管道的每个值执行一些操作。明白了吗？ Pipe ？ Tap ？ 你可以这么编写 <code>tap()</code> ：</p><script src="//gist.github.com/459b2bc590b89c2e0bea27ebac385e7f.js?file=tap.js"></script><p>现在你知道为什么 <code>trace()</code> 是 <code>tap()</code> 的一个特例：</p><script src="//gist.github.com/4981bbb10a15deab96ecbf34da3c9f34.js?file=tapped-trace.js"></script><p>你应该开始了解函数式编程是什么了，以及 <strong>偏函数应用(partial application)</strong> 和 <strong>柯里化(currying)</strong> 是如何协同 <strong>函数组合(function composition)</strong> 来帮助你编写更易读且更少样板的程序。</p><p><strong>探索 ‘Master the JavaScript Interview’ 系列</strong></p><ul><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">What is a Closure?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">What is the Difference Between Class and Prototypal Inheritance?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">What is a Pure Function?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">What is a Function Composition?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">What is a Function Programming?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">What is a Promise?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466" target="_blank" rel="noopener">Soft Skills</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】JavaScript 工作原理：JS 引擎，runtime 和调用栈的概述</title>
      <link href="/2018/09/10/trans-8/"/>
      <url>/2018/09/10/trans-8/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">How JavaScript works: an overview of the engine, the runtime, and the call stack</a></p></blockquote><p>JavaScript 变得越来越流行，很多团队在他们技术栈的多个方面使用它：前端，后端，hybrid 应用，嵌入式设备等等。</p><p>这篇是本系列文章的第一篇，旨在深入挖掘 JavaScript 和其实际工作原理：我们认为，通过了解 JavaScript 的构建块以及它们是如何协同工作的，你将能编写更好的代码和应用程序。我们还将分享我们在构建 <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=source&amp;utm_content=javascript-series-post1-intro" target="_blank" rel="noopener">SessionStack</a> 时使用的一些经验规则，SessionStack 是一个轻量级 JavaScript 应用，它稳定且性能强大以保持竞争力。</p><a id="more"></a><p>根据 <a href="http://githut.info/" target="_blank" rel="noopener">GitHut stars</a> 显示，就 Active Repositories 和 Total Pushes 而言 JavaScript 在 GitHub 中是最高的。在其他类别中也没有落后很多。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Zf4reZZJ9DCKsXf5CSXghg.png" alt="GitHut"></p><p><a href="https://madnight.github.io/githut/" target="_blank" rel="noopener">(Check out up-to-date GitHub language stats)</a></p><p>如果项目越发的依赖于 JavaScript，这意味着为了构建令人惊叹的软件，开发人员必须利用 JS 语言和生态所提供的所有内容，对其内部深入理解。</p><p>事实证明，有很多开发者每天都在使用 JavaScript ，但却不了解其内部原理。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>几乎所有开发人员都知道 V8 引擎的概念，并且大多数开发人员了解 JavaScript 是单线程 (single-threaded) 的或者说它使用了回调队列 (callback queue)。</p><p>在这篇文章中，我们将详细介绍这些概念并解释 JavaScript 的实际运行方式。通过了解这些细节，你可以正确利用提供的 APIs 来编写更好的非阻塞的应用。</p><p>如果你是 JavaScript 萌新，这篇文章将会帮助你理解为什么 JavaScript 与其他编程语言相比如此“奇怪”。</p><p>如果你是一位资深 JavaScript 开发人员，希望这篇文章可以为你提供一些关于你每天使用的 JavaScript Runtime 实际工作原理的新见解。</p><h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>Google 的 V8 引擎是一个流行的 JavaScript 引擎。V8 引擎应用与 Chrome 和 Node.js 。下面是它的一个非常简化的视图：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*OnH_DlbNAPvB9KLxUCyMsA.png" alt="V8 engine"></p><p>V8 引擎包含两个主要组件：</p><ul><li>内存堆 —— 进行内存分配</li><li>调用栈 —— 代码执行/栈帧</li></ul><h2 id="运行时-Runtime"><a href="#运行时-Runtime" class="headerlink" title="运行时 (Runtime)"></a>运行时 (Runtime)</h2><p>几乎所有 JavaScript 开发人员都使用过浏览器中的 APIs (e.g. <code>setTimeout</code>) 。但是这些 APIs 不是由 JavaScript 引擎提供的。</p><p>所以，它们从何而来？</p><p>事实正面现实有点复杂。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*4lHHyfEhVB0LnQ3HlhSs8g.png" alt="APIs"></p><p>所以，我们有 JavaScript 引擎，但是实际上还有更多。我们有一些由浏览器提供的叫做 Web APIs 的东西，比如 DOM, AJAX, setTimeout 等等。</p><p>然后，我们还有 <strong>事件循环 (event loop)</strong> 和 <strong>回调队列 (callback queue)</strong> 。</p><h2 id="调用栈-Call-Stack"><a href="#调用栈-Call-Stack" class="headerlink" title="调用栈 (Call Stack)"></a>调用栈 (Call Stack)</h2><p>JavaScript 是一个单线程编程语言，这意味着它只有一个调用栈。因此在同一时间它执行一个任务。</p><p>调用栈是一种我们程序中的基本记录的数据结构。如果进入一个函数，我们将它放在调用栈的顶层。如果返回一个函数，我们将其从调用栈的顶层弹出。这是调用栈能做的所有事情。</p><p>让我们看一个示例。看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = multiply(x, x)</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSquare(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>当 JavaScript 引擎开始执行代码时，调用栈是空的。之后的步骤如下：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Yp1KOt_UJ47HChmS9y7KXw.png" alt="Call Stack"></p><p>调用栈的每个入口称为 <strong>栈帧 (Stack Frame)</strong> 。</p><p>当抛出异常可以看到堆栈追踪是如何构造的 —— 当发生异常时，它就是调用栈的状态。看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes:'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br></pre></td></tr></table></figure><p>如果在 Chrome 中执行 (假设是 foo.js 中的代码) ，将会生成下面的堆栈追踪：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*T-W_ihvl-9rG4dn18kP3Qw.png" alt="Stack Trace"></p><p>“<strong>堆栈溢出 (Blowing the stack)</strong>“ —— 当达到最大调用栈大小的时候发生。这很容易发生，特别是如果你使用递归但没有全面的测试。看下面的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当 JavaScript 引擎开始执行这段代码，开始调用 <code>foo</code> 函数。但是在没有终止条件的情况下 <code>foo</code> 会递归的调用自己。所以每执行一步，就会把这个相同的函数一次又一次的添加到调用栈中。看起来像下面这样：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*AycFMDy9tlDmNoc5LXd9-g.png" alt="Blowing the stack"></p><p>但是，在某一时刻，调用栈中的函数调用数量超过了调用栈的实际大小，浏览器通过抛出一个错误来结束它。如下所示：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*e0nEd59RPKz9coyY8FX-uw.png" alt="Maximum"></p><p>在单线程上运行代码非常简单，因为你不需处理多线程环境中出现的复杂场景 —— 例如 死锁 (deadlocks) 。</p><p>但是单线程也有很大的限制。由于 JavaScript 只有一个调用栈，如果运行很慢会发生什么？</p><h2 id="并发和事件循环-Concurrency-amp-Event-Loop"><a href="#并发和事件循环-Concurrency-amp-Event-Loop" class="headerlink" title="并发和事件循环 (Concurrency &amp; Event Loop)"></a>并发和事件循环 (Concurrency &amp; Event Loop)</h2><p>如果在调用栈中有函数需要花费大量时间才能处理，会发生什么？例如，假设你需要在浏览器中使用 JavaScript 进行一些复杂的图像转换。</p><p>你可能会问，为什么这是一个问题？问题是，当调用栈有函数要执行，浏览器实际不会做其他任何事 —— 浏览器被阻塞了。这意味着浏览器不能渲染，不能运行任何其他代码，它被卡住了。如果你想要在 app 中拥有流畅的 UI 体验，这将是个问题。</p><p>并且这不是唯一的问题。一旦你的浏览器开始在调用栈中处理如此多的任务，它可能在相当长的时间内停止响应。大多数浏览器会弹出一个错误，询问是否终止网页。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*WlMXK3rs_scqKTRV41au7g.jpeg" alt="Unresponsive"></p><p>这并不是最好的用户体验，不是吗？</p><p>那么，如何在不阻塞 UI 和不弹出无响应的情况下执行复杂的代码？解决方法是 <strong>异步回调 (asynchronous callbacks)</strong> 。</p><p>这将在 “How JavaScript actually works” 第2篇中详细解释：”<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">Inside the V8 engine + 5 tips on how to write optimized code</a>“ 。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是纯函数（Pure Function）？</title>
      <link href="/2018/09/10/trans-6/"/>
      <url>/2018/09/10/trans-6/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">Master the JavaScript Interview: What is Pure Function?</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*gF8oCkYNvktBbAAG-nxYrg.jpeg" alt="Image: Pure - carnagenyc (CC BY 2.0)"></p><p>纯函数对于包括函数式编程，可靠并发和 React+Redux apps 等用途至关重要。但是 “pure function” 是什么意思呢？</p><a id="more"></a><p>我们可以在一个免费的课程中学到这个问题的答案 – <a href="http://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“Learn JavaScript with Eric Elliott”</a> :</p><div class="video-container"><iframe src="//player.vimeo.com/video/160326750" frameborder="0" allowfullscreen></iframe></div><p>在我们理解纯函数之前，仔细研究函数可能时一个好主意。可以从不同方式去观察它们，让我们更容易理解函数式编程 (functional programming) 。</p><h2 id="什么是函数-Function-？"><a href="#什么是函数-Function-？" class="headerlink" title="什么是函数 (Function) ？"></a>什么是函数 (Function) ？</h2><p>函数是接收输入 (<strong>参数</strong>) 并产生输出 (<strong>返回值</strong>) 的过程。函数有以下用途：</p><ul><li><p><strong>映射 (Mapping)</strong> ：基于输入产生一些输出。函数是输入值到输出值的映射。</p></li><li><p><strong>过程 (Procedures)</strong> ：调用函数来执行一个序列的步骤。这个序列被称为过程，并且这种编程风格被称为<strong>过程编程 (procedural programming)</strong> 。</p></li><li><p><strong>I/O</strong> ：存在一些函数需要和系统的其他部分通信，例如屏幕，存储，系统日志，或者网络。</p></li></ul><h2 id="映射-Mapping"><a href="#映射-Mapping" class="headerlink" title="映射 (Mapping)"></a>映射 (Mapping)</h2><p>纯函数都是关于映射的。函数将参数映射成返回值，意味着对于每一组输入都存在一个输出。函数会接收输入并且返回相应的输出。</p><p><code>Math.max()</code> 接收多个数值作为参数并且返回最大的数值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>在这个例子中，2，8 和 5 作为参数。传入函数中的值。</p><p><code>Math.max()</code> 函数接收任意数量的数值作为参数并且返回参数中最大的值。在这个例子中，传入的最大的数值是 8 ，它就是我们要返回的值。</p><p>函数在计算和数学中非常重要。它们帮助我们正确地使用数据。优秀的程序员会使用有意义的函数名，当我们看代码时，通过函数名就知道这个函数是做什么的。</p><p>数学也有函数，它们和 JavaScript 的函数类似。你可能在代数中看到过函数。像下面这样：</p><p><em>f(x) = 2x</em></p><p>这以为了我们定义了一个叫做 f 的函数并且有参数 x 然后用 2 乘以 x 。</p><p>我们可以使用一个值代替 x 来运用这个函数：</p><p><em>f(2)</em></p><p>在代数中，这和写 4 的意义完全相同。<br><br>所以任何地方出现的 <em>f(2)</em> 都可以用 4 代替。</p><p>现在我们转换这个函数为 JavaScript 的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>你可以使用 <code>console.log()</code> 函数输出来检验：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( double(<span class="number">5</span>) ) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>还记得我说过可以用 <code>4</code> 来替换 <code>f(2)</code> ，这种情况下， JavaScript 引擎使用 <code>10</code> 替换了 <code>double(5)</code> 。</p><p>所以 <code>console.log(double(5))</code> 和 <code>console.log(10)</code> 相同。</p><p>因为 <code>double()</code> 是纯函数所以这是正确的，但是如果 <code>double()</code> 有副作用，例如保存数据到磁盘或者记录到控制台，在不改变函数含义的情况下你不能简单地用 <code>10</code> 替换 <code>double(5)</code> 。</p><p>如果你想引用透明，你需要使用纯函数。</p><h2 id="纯函数-Pure-Functions"><a href="#纯函数-Pure-Functions" class="headerlink" title="纯函数 (Pure Functions)"></a>纯函数 (Pure Functions)</h2><p><strong>纯函数</strong>是：</p><ul><li><p>给予相同的输入，总是返回相同的输出。</p></li><li><p>不产生副作用</p></li></ul><blockquote><p><em>A dead giveaway that a function is impure is if it makes sense to call it without using its return value. For pure functions, that’s a noop.</em></p></blockquote><p>我建议你爱上纯函数。意思是如果使用纯函数可以实现程序要求，你应该选择纯函数而非其他。纯函数接收一些输入然后返回基于这些输入的输出。它们是构建程序的最简单可复用模块。也许计算机科学的最重要的设计原则是 KISS (Keep It Simple, Stupid) 。我更喜欢 Keep It Stupid Simple 。纯函数是傻瓜简单的最有可能的方式。</p><p>纯函数具有很多有益属性，并且是构建<strong>函数式编程</strong>的基础。纯函数是完全独立于外部状态的，因此，它们免疫于于共享可变状态相关这一类型的 bugs 。纯函数的独立性使其成为处理跨多个 CPU 及跨整个分布式计算机集群的理想选择，这使它们成为很多科学种类和资源密集型计算任务的必要条件。</p><p>纯函数也是极其独立的 – 代码易于转换，重构，重组，使你的程序更灵活且更适应未来的改变。</p><h3 id="共享状态-Shared-State-的问题"><a href="#共享状态-Shared-State-的问题" class="headerlink" title="共享状态 (Shared State) 的问题"></a>共享状态 (Shared State) 的问题</h3><p>几年前，我当时正在开发一款 app ，允许用户从数据库中搜索音乐家并将这个音乐家的音乐列表加载到网络播放器。在那个时间 Google Instant 出现，当你键入搜索查询会即时显示搜索结果。AJAX 驱动的自动完成突然风靡一时。</p><p>唯一的问题是用户输入速度比 API 自动完成搜索的返回值要快，这会导致奇怪的问题。这会触发竞争条件 (race condition) ，较新的结果会被过时的结果覆盖。</p><p>为什么会发生这个？因为每个 AJAX 请求成功后都可以直接显示在用户的建议列表上。最慢的 AJAX 请求总是盲目地替换结果显示给用户，即使被替换的结果可能是较新的。</p><p>为了解决这个问题，我创建了一个建议管理器 – 管理查询建议状态的唯一数据来源。已知当前正在等待的 AJAX 请求，当用户新键入后，这个等待的 AJAX 请求将会取消并且发起一个新请求，所以同一时间只有一个响应处理函数能够触发 UI 更新。</p><p>任何类型的异步或同步操作都可能导致类似的竞争条件。如果输出取决于不可控事件的序列 (例如网络，设备延迟，用户输入，随机性等) ,则会发生条件竞争。事实上，如果你在使用共享状态并且这个状态依赖于根据不确定因素而变化的序列，则无论出于何种意图和目的，输出都是不可预测的，这意味着无法正确测试和完全理解。正如 Martin Odersky (Scala 创造者) 所说：</p><blockquote><p>non-determinism = parallel processing + mutable state</p></blockquote><p>程序确定性通常是计算机应用中的理想属性。也许你认为 JS 在单线程中运行，因此不受并行处理问题的影响，但正如 AJAX 示例所示，单线程 JS 引擎并不意味着没有并发性。相反的，JavaScript 中存在很多并发源 (API I/O, 事件监听, web workers, iframes, timeouts) 向程序中引入不确定性。将这些与共享状态结合，你会得到一堆 bugs 。</p><p>纯函数可以帮助你避免这些 bugs 。</p><h3 id="接收同样的输入，总是返回同样的输出"><a href="#接收同样的输入，总是返回同样的输出" class="headerlink" title="接收同样的输入，总是返回同样的输出"></a>接收同样的输入，总是返回同样的输出</h3><p>使用 <code>double()</code> 函数，你可以用结果替换函数调用，并且程序会认为是同一件事， <code>double(5)</code> 和 <code>10</code> 在程序应用中是同一个意思，无论上下午如何，无论调用的次数和时间。</p><p>但并不是所有的函数都是和结果一直相同。某些函数还依赖于传入参数之外的信息来生成结果。</p><p>思考这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random()   <span class="comment">// 0.4619094094074556</span></span><br><span class="line"><span class="built_in">Math</span>.random()   <span class="comment">// 0.602651887966867</span></span><br><span class="line"><span class="built_in">Math</span>.random()   <span class="comment">// 0.9958664270880297</span></span><br></pre></td></tr></table></figure><p>即使我们没有传入任何参数到上面的函数调用中，它们生成了不同的输出，这意味着 <code>Math.random()</code> 不是纯函数。</p><p><code>Math.random()</code> 函数在每次调用后会生成一个新的在 0 和 1 之间的随机数，所以很明显你不能在不改变程序含义的情况下用 <code>0.4619094094074556</code> 替换 <code>Math.random()</code> 函数。</p><p>如果替换了每次都会产生相同的结果。当我们向计算机询问一个随机数时，通常意味着我们想要不同于上一次的结果。所有侧面都是相同数字的骰子有什么意思？</p><p>有时我们会向计算机询问当前时间。我们不会详细介绍时间函数的工作原理。现在，复制下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">time() <span class="comment">// =&gt; "2:20:34 PM"</span></span><br></pre></td></tr></table></figure><p>如果用当前时间替换 <code>time()</code> 函数调用会发生什么？</p><p>它将会一直输出相同的时间：那个替换函数调用的时间。换句话说，每天只能生成一个正确的输出，并且只有在替换函数调用的时间的确切时刻运行程序才会生成。</p><p>所以很明显， <code>time()</code> 和 <code>double()</code> 不同。</p><p>只有给定相同的输入，一定生成相同的输出的函数才是纯函数。你可能记得袋鼠中的这个规则，相同的输入值总是映射到相同的输出值。然而，不同的输入值可以映射到相同的输出值。例如，下面这个函数是纯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highpass = <span class="function">(<span class="params">cutoff, value</span>) =&gt;</span> value &gt;= cutoff</span><br></pre></td></tr></table></figure><p>相同的输入值总是映射到相同的输出值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">highpass(<span class="number">5</span>, <span class="number">5</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">5</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">5</span>) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>不同的输入值可以映射到相同的输出值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">highpass(<span class="number">5</span>, <span class="number">123</span>) <span class="comment">// true</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">18</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line">highpass(<span class="number">5</span>, <span class="number">4</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>纯函数一定不可以依赖任何外部可变状态，以为这样函数将不再具有确定性和引用透明。</p><h2 id="纯函数不会产生副作用-No-Side-Effects"><a href="#纯函数不会产生副作用-No-Side-Effects" class="headerlink" title="纯函数不会产生副作用 (No Side Effects)"></a>纯函数不会产生副作用 (No Side Effects)</h2><p>纯函数不会产生副作用，意思是它不能改变任何外部状态。</p><h2 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性 (Immutability)"></a>不可变性 (Immutability)</h2><p>JavaScript 的对象参数是引用，这意味着如果函数改变了一个对象或数组参数的属性，也会改变在函数外部的状态。纯函数一定不会改变外部状态。</p><p>思考这个可变的，非纯函数 <code>addToCart()</code></p><script src="//gist.github.com/27d689731f703fa0e095c0dc524728c6.js?file=impure-add-to-cart.js"></script><p>它的工作原理是传入 cart，item 和 quantity (购物车，商品种类和商品数量) 。函数会将 item 添加到 cart 并返回 cart。</p><p>这个函数的问题是我们刚刚改变了一些共享状态。其他函数可能依赖于调用函数之前状态的 cart ，现在我们已经改变了共享状态，如果我们改变调用函数的顺序，我们不得不担心它会对程序逻辑产生什么影响。重构代码可能导致产生 bugs ，这可能会搞砸订单，导致客户生气。</p><p>现在思考这个版本：</p><script src="//gist.github.com/56ef48bc044251fe44203703ed6902d7.js?file=pure-add-to-cart.js"></script><p>在这个示例中，因为对象中嵌套了一个数组，所以需要深克隆。这比你一般处理的状态更复杂。大多数情况下，你可以将其分解成更小的块。</p><p>例如， Redux 允许你组合 reducers 而不是在每个 reducer 中处理整个 app 状态。结果是，每次你想要更新其中的一小部分时，不必创建整个 app 状态的深克隆。相反的，你可以使用 non-destructive 数组方法或 <code>Object.assign()</code> 来更新 app 状态的一小部分。</p><h2 id="探索-‘Master-the-JavaScript-Interview’-系列"><a href="#探索-‘Master-the-JavaScript-Interview’-系列" class="headerlink" title="探索 ‘Master the JavaScript Interview’ 系列"></a>探索 ‘Master the JavaScript Interview’ 系列</h2><ul><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">What is a Closure?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">What is the Difference Between Class and Prototypal Inheritance?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">What is a Pure Function?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">What is a Function Composition?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">What is a Function Programming?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">What is a Promise?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466" target="_blank" rel="noopener">Soft Skills</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是 Promise？</title>
      <link href="/2018/09/10/trans-5/"/>
      <url>/2018/09/10/trans-5/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Promise?</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/1600/1*agGENodMcD6hhwIFdqGwrw.jpeg" alt="Photo by Kabun (CC BY NC SA 2.0)"></p><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><h2 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h2><p>Promise 是一个对象，在未来的某个时刻产生一个值：已完成 (resolved) 的值或者是未完成的原因(e.g. 网络错误)。Promise 可能是下面三种状态中的一种：fulfilled，rejected，pending 。Promise 提供回调来处理 fulfilled 返回的值或者 rejection 的原因。</p><a id="more"></a><p>Promise 会立即执行，这意味着一旦 promise 构造函数被调用，promise 就会开始执行你给它的任何任务。如果你需要 promise 懒加载，参考 <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="noopener">observables</a> 或者 <a href="https://github.com/rpominov/fun-task" target="_blank" rel="noopener">tasks</a>。</p><h2 id="Promise-的不完全历史"><a href="#Promise-的不完全历史" class="headerlink" title="Promise 的不完全历史"></a>Promise 的不完全历史</h2><p>早在1980年代，promise 和 futures (类似/相关的想法) 的早期实现开始出现在 MultiLisp 和 Concurrent Prolog 等语言中。“promise” 这个概念是由 Barbara Liskov 和 Liuba Shrira 在1998年提出。</p><p>我第一次听说 JavaScript 中的 promise，Node 才刚刚出现，Node 社区正在讨论异步行为的最佳方案。社区实验了一段时间 promise，但最终选择了 error-first 回调作为 Node 标准。</p><p>大概在同一时间，Dojo 通过 Deferred API 添加了 promises 。不断增长的兴趣和活跃度最终导致了新的 Promises/A 规范的形成，提高了不同 promises 之间的互操作性。</p><p>jQuery 的异步操作是围绕 promises 的重构。jQuery 的 promise 和 Dojo 的 Deferred 非常相似，并且由于 jQuery 的流行，它一度在 JavaScript 中被广泛使用。但是 <a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener"> it did not support the two channel (fulfilled/rejected) chaining behavior &amp; exception management</a> 人们期望在 promise 上的构建工具。</p><p>尽管有这些缺点，jQuery 让 JavaScript promise 成为主流，并且一下更好的独立的 promise 库，例如 Q ， When ， 和 Bluebird 变得非常流行。jQuery 的实现的不兼容性促使 promise 规范中的一些重要说明，它被重写并重命名为 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+ specification</a> 。</p><p>ES6 使用了遵循 Promises/A+ 兼容的 Promise 作为全局变量，并且一些非常重要的 API 构建在新的 Promise 标准之上：特别是 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">WHATWG Fetch</a> 规范和 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">Async Functions</a> 标准(第3阶段草案)</p><p>本文描述的是与 Promises/A+ 规范兼容的 promise，着重于基于 ECMAScript 标准的 <code>Promise</code> 实现。</p><h2 id="Promises-是如何工作的"><a href="#Promises-是如何工作的" class="headerlink" title="Promises 是如何工作的"></a>Promises 是如何工作的</h2><p>promise 是一个从异步函数同步返回的对象。它有3种可能的状态：</p><ul><li><p><strong>Fulfilled：</strong> 将会调用 <code>onFulfilled()</code> (e.g.， 调用 <code>resolve()</code>)</p></li><li><p><strong>Rejected：</strong> 将会调用 <code>onRejected()</code> (e.g.， 调用 <code>reject()</code>)</p></li><li><p><strong>Pending：</strong> 非 fulfilled 或者 rejected</p></li></ul><p>如果 promise 不在 pending 状态，它就固定了(处于 fulfilled 或 rejected)。有时我们用 <em>resolved</em> 或 <em>settled</em> 表示同一件事：<em>not pending</em> 。</p><p>promise 一旦被固定，就不能重新固定。调用 <code>resolve()</code> 或 <code>reject()</code> 将没有效果。被固定的 promise 的不可变性是一个重要的特性。</p><p>原生 JavaScript promise 不暴露 promise 状态。相反，你应该把 promise 视为一个黑盒。只有创建这个 promise 的函数才知道 promise 的状态，或者说有 <code>resolve</code> 或 <code>reject</code> 的权限。</p><p>这是一个返回一个 promise 的函数，并在制定的时间延迟后 <code>resolve</code> 。</p><script src="//gist.github.com/2dbea5f98fde8a0a77eb93775aa97468.js?file=wait.js"></script><p>调用 <code>wait(3000)</code> 会等待3000毫秒 (3秒) ，然后调用打印 <code>&#39;Hello!&#39;</code> 。所以与规范兼容的 promise 都定义了 <code>.then()</code> 方法，你可以传入一个函数来处理 <code>resolve</code> 或 <code>reject</code> 返回的值。</p><p>ES6 promise 的构造函数需要一个函数。这个函数需要两个参数，<code>resovle()</code> 和 <code>reject()</code> 。在上面的例子中，我们只使用了 <code>resolve()</code> ,将 <code>reject()</code> 从参数列表中删除了。我们调用 <code>setTimeout()</code> 来创建延迟，并在完成后调用 <code>resolve()</code> 。</p><p>你可以按需向 <code>resolve()</code> 或 <code>reject()</code> 中传值，这个值会作为参数传入 <code>.then()</code> 的回调函数。</p><p>当我调用 <code>reject()</code> 并且传入一个值，我总是传入一个 <code>Error</code> 对象。一般来说，我想要两种可能的解决状态：正常的或异常的 (阻碍正常状态) 。传入一个 <code>Error</code> 对象来表示。</p><h2 id="Promise-的重要规则"><a href="#Promise-的重要规则" class="headerlink" title="Promise 的重要规则"></a>Promise 的重要规则</h2><p>标准的 Promise 是由 <a href="https://promisesaplus.com/implementations" target="_blank" rel="noopener">Promises/A+ specification</a> 社区定义的。有很多符合标准的实现，包括 JavaScript ECMAScript promise。</p><p>Promise 必须遵循下面的规则：</p><ul><li><p>Promise 或 “thenable” 需要提供标准的 <code>.then()</code> 方法。</p></li><li><p>pending 状态的 promise 可以转换为 fulfilled 或 rejected 状态。</p></li><li><p>fulfilled 或 rejected 状态的 promise 是固定的，不能转换为其他状态。</p></li><li><p>一旦 promise 固定，一定有一个值 (可以是 undefined) 。这个值不可变。</p></li></ul><p>在这个上下午的变更指的是恒等 (===) 。fulfilled 的值可以是一个对象，这个对象的属性是可变的。</p><p>所以的 promise 都必须实现具有下面方法签名的 <code>.then()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    onFulfilled? : <span class="built_in">Function</span>,</span><br><span class="line">    onRejected? : <span class="built_in">Function</span></span><br><span class="line">) =&gt; <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p><code>.then()</code> 方法必须符合一下规则：</p><ul><li><p><code>onFulfilled()</code> 和 <code>onRejected()</code> 都是可选的。</p></li><li><p>如果提供的参数不是函数，必须忽略。</p></li><li><p><code>onFulfilled()</code> 在 promise 转换为 fulfilled 状态时被调用，promise 的值作为这个函数第一个参数。</p></li><li><p><code>onRejected()</code> 在 promise 转换为 rejected 状态后被调用，拒绝的原因作为第一个参数。原因可以是任何有效的 JavaScript 值，但是拒绝基本和异常是同义词，所以我建议使用 Error 对象。</p></li><li><p><code>onFulfilled()</code> 和 <code>onRejected()</code> 都不能多次调用。</p></li><li><p><code>.then()</code> 可以在同一个 promise 上多次调用。换句话说，可以使用 promise 来聚合回调。</p></li><li><p><code>.then()</code> 一定会返回一个 promise， <code>promise2</code> 。</p></li><li><p>如果 <code>onFulfilled()</code> 或 <code>onRejected()</code> 的返回值为 <code>x</code> ，并且 <code>x</code> 是一个 promise ， <code>promise2</code>  会被锁定 (假设和 <code>x</code> 有相同的状态和值) 。 否则， <code>promise2</code> 将会转换为 fulfilled 状态并且值为 <code>x</code> 。</p></li><li><p>不论 <code>onFulfilled</code> 或 <code>onRejected</code> 跑出一个异常 <code>e</code> ， <code>promise2</code> 一定会 rejected 并且 <code>e</code> 作为原因。</p></li><li><p>如果 <code>onFulfilled</code> 不是一个函数并且 <code>promise1</code> 处于 fulfilled 状态， <code>promise2</code> 一定是 fulfilled 状态并且和 <code>promise1</code> 有同样的值。</p></li><li><p>如果 <code>onRejected</code> 不是一个函数并且 <code>promise1</code> 处于 rejected 状态， <code>promise2</code> 一定是 rejected 状态并且和 <code>promise1</code> 的原因相同。</p></li></ul><h2 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h2><p>因为 <code>.then()</code> 总是返回一个新的 promise ，所以可以链接 promises 并精确控制错误的处理方式和位置。Promises 允许你模仿同步代码的 <code>try/catch</code> 方式。</p><p>链式调用会形成一个有序的序列，类似于同步代码。换句话说，你可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">    .then(process)</span><br><span class="line">    .then(save)</span><br><span class="line">    .catch(handleErrors)</span><br></pre></td></tr></table></figure><p>假设 <code>fetch()</code> <code>process()</code> <code>save()</code> 每个函数都返回 promises ， <code>fetch()</code> 完成后 <code>process()</code> 才开始执行， <code>process()</code> 完成后 <code>save()</code> 才开始执行。任何一个 promise reject 后 <code>handleErrors()</code> 才会执行。</p><p>这是一个复杂的 promise 链 的例子，并具有多个 rejection：</p><script src="//gist.github.com/8a49bbbf15e697182a5dd9edafd765e9.js?file=promise-chaining.js"></script><h2 id="Error-处理"><a href="#Error-处理" class="headerlink" title="Error 处理"></a>Error 处理</h2><p>注意 promise 同时有成功和错误的 handler ，下面的代码很常见：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save().then(</span><br><span class="line">    handleSuccess,</span><br><span class="line">    handleError</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但是 <code>handleSuccess()</code> 抛出错误应该怎么做？从 <code>.then()</code> 返回的 promise 将会 rejected ，但是没有捕捉到这个 rejection 。意味着你的 app 的这个错误被吞了。</p><p>出于这个原因，有些人认为上面的代码是反模式的，并推荐下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save()</span><br><span class="line">    .then(handleSuccess)</span><br><span class="line">    .catch(handleError)</span><br></pre></td></tr></table></figure><p>差异很微妙但是很重要。在第一个示例中， 源自 <code>save()</code> 的错误将会被捕获， 但源自 <code>handleSuccess()</code> 的错误将会被吞掉。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*5Z_vNz6xHn9mjTgvrqa2Aw.png" alt="Without .catch(), an error in the success handler is uncaught."></p><p>在第二个示例中，<code>.catch()</code> 可以处理 <code>save()</code> 和 <code>handleSuccess()</code> 两者的 rejection 。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*vRaV9sYpYKdxBj3Ld7KM1Q.png" alt="With .catch(), both error sources are handled."></p><p>当然， <code>save()</code> 的错误可能是网络错误，但 <code>handleSuccess()</code> 的错误可能是开发人员忘记处理特定的状态码。如果你想以不同的方式处理它们，你可以选择这样处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save()</span><br><span class="line">    .then(</span><br><span class="line">        handleSuccess,</span><br><span class="line">        handleNetworkError</span><br><span class="line">    )</span><br><span class="line">    .catch(handleProgrammerError)</span><br></pre></td></tr></table></figure><p>无论你喜欢哪一种方式，我都建议在所有的 promise 链都是以 <code>.catch()</code> 结尾。重复这么做是值得的：</p><blockquote><p><em>I recommend ending all promise chains with a .catch().</em></p></blockquote><h2 id="如何取消一个-Promise？"><a href="#如何取消一个-Promise？" class="headerlink" title="如何取消一个 Promise？"></a>如何取消一个 Promise？</h2><p>promises 萌新经常想知道的第一件事是如何取消一个 promise。这是一个想法：以 “Cancelled” 为原因 reject promise 。如果你想和 “normal” 错误以不同的处理方式，在 error handler 中添加一个处理分支。</p><p>以下是人们在取消 promise 时所犯的一些常见错误：</p><h3 id="在-promise-中添加-cancel"><a href="#在-promise-中添加-cancel" class="headerlink" title="在 promise 中添加 .cancel()"></a>在 promise 中添加 .cancel()</h3><p>添加 .cancel() 使 promise 不符合标准，而且也违反了一些 promises 的规则：只有创建 promise 的函数才能 resolve， reject，或者 cancel 这个 promise 。暴露出来会破坏 promise 的封装，并且会鼓励人们在不应该知道 promise 的地方编写操作 promise 的代码。避免意大利面式的代码以及破坏 promises 。</p><h3 id="忘记清理"><a href="#忘记清理" class="headerlink" title="忘记清理"></a>忘记清理</h3><p>有一些聪明的人发现可以使用 <code>Promise.race()</code> 组委取消机制。问题是使用了创建 promise 的函数来做取消控制，只有这个函数可以清理活动内容，例如清理 timeouts 或者清理数据引用的内存空间等等。</p><h3 id="忘记处理-rejected-状态下取消-promise"><a href="#忘记处理-rejected-状态下取消-promise" class="headerlink" title="忘记处理 rejected 状态下取消 promise"></a>忘记处理 rejected 状态下取消 promise</h3><p>你知道吗当你忘记处理 promise rejection ， Chrome 控制台会抛出一个警告信息。</p><h3 id="过度复杂"><a href="#过度复杂" class="headerlink" title="过度复杂"></a>过度复杂</h3><p><a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">withdrawn TC39 proposal</a> 提出了使用独立的消息通道实现取消 promise 。它提出了一个叫做 cancellation token 的新概念。在我看来，这个解决方案会让 promise 规范变得臃肿，它的唯一作用是分离了 rejections 和 cancellations ，这是没有必要的。</p><p>你是否希望基于 exception 或者 cancellation 来进行切换？这确实是 promise 的工作？我认为不是。</p><h3 id="重新思考-Promise-Cancellation"><a href="#重新思考-Promise-Cancellation" class="headerlink" title="重新思考 Promise Cancellation"></a>重新思考 Promise Cancellation</h3><p>通常，在 promise 创建时传入所有需要的信息以确定如何 resolve / reject / cancel 这个promise 。这样就没有必要在 promise 上添加 <code>.cancel()</code> 函数了。你可能会有疑问，在 promise 创建的时候怎么知道是否可以取消。</p><blockquote><p><em>“If I don’t yet know whether or not to cancel, how will I know what to pass in when I create the promise?”</em></p></blockquote><p>如果只有某种对象可以代替未来的潜在的值…等一下。</p><p>我们传入的那个代表是否取消的值可以是一个 promise 。可能是这样：</p><script src="//gist.github.com/acb7f555a2f8b4ba93807105da5e11ae.js?file=cancellable-wait.js"></script><p>我们使用的默认参数默认是不取消的。<code>cancel</code> 参数是可选的。像之前一样设定一个 settimeout ，不过会保存这个 timeout 的 ID 以便于在之后清理。</p><p>我们使用 <code>cancel.then()</code> 方法来处理 cancellation 和资源清理。这个方法只会在 promise resolve 之前取消了才会执行。如果你太晚取消，你就错过了你的机会。火车已经驶离了车站。</p><blockquote><p><em>注意：你可能想知道 <code>noop()</code> 函数是做什么的。单词 noop 代表了 no-op，意思是空函数什么都不做。如果没有这个函数，V8 引擎会抛出警告：<code>UnhandledPromiseRejectionWarning: Unhandled promise rejection</code> 。永远都要处理 promise rejections 是一个好主意，即使是 <code>noop()</code> 函数。</em></p></blockquote><blockquote><p><em>Note: You may be wondering what the noop() function is for. The word noop stands for no-op, meaning a function that does nothing. Without it, V8 will throw warnings: UnhandledPromiseRejectionWarning: Unhandled promise rejection. It’s a good idea to <strong>always handle promise rejections</strong>, even if your handler is a noop().</em></p></blockquote><h3 id="抽象-Promise-Cancellation"><a href="#抽象-Promise-Cancellation" class="headerlink" title="抽象 Promise Cancellation"></a>抽象 Promise Cancellation</h3><p>这对于 <code>wait()</code> 计时器是很好的，但是我们可以进一步抽象这个想法，封装所有你需要的：</p><ol><li><p>默认拒绝 cancel promise – 如果没有传入 cancel 到 promise ，我们不希望 cancel 或抛错。</p></li><li><p>记住因 cancellations 而 reject 时要进行清理。</p></li><li><p>记住 <code>onCancel</code> 的清理工作本身也会抛错，这个错误也需要处理。(注意上面的示例中省略了错误处理 – 很容易忘记！)</p></li></ol><p>让我们来创建一个可取消的 promise 工具，你可以使用它来包装任何 promise 。例如，处理网络请求等… 方法前面如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">speculation(fn: SpecFunction, <span class="attr">shouldCancel</span>: <span class="built_in">Promise</span>) =&gt; <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>SpecFunction 就像你传入 <code>Promis</code> 的构造函数一样，有一点不同 – 它有一个 <code>onCancel()</code> handler：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpecFunction(resolve: <span class="built_in">Function</span>, <span class="attr">reject</span>: <span class="built_in">Function</span>, <span class="attr">onCancel</span>: <span class="built_in">Function</span>) =&gt; <span class="keyword">void</span></span><br></pre></td></tr></table></figure><script src="//gist.github.com/3dcf478645b131c3259456794861840a.js?file=speculation.js"></script><p>注意这个例子只是向你解释它是如何工作的。还有一些其他边界问题需要考虑。例如，这个版本的代码，promise 已经固定了，取消 promise 依然会调用 <code>handleCancel</code> 函数。</p><p>我实现了一个生产版本，处理了边界问题的开源库，<a href="https://github.com/ericelliott/speculation" target="_blank" rel="noopener">Speculation</a> .</p><p>让我们使用这个改进的抽象库来重写之前的 <code>wait()</code> 工具函数。首先安装 speculation：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save speculation</span><br></pre></td></tr></table></figure><p>现在你可以导入和使用它：</p><script src="//gist.github.com/36ab3548b44a0833ddb3bb69745e18b9.js?file=wait-speculation.js"></script><p>这简化了一些，因为你不需要关心 <code>noop()</code> ， 捕获 <code>onCancel()</code> ，函数或其他边界问题的错误。这些细节都被抽象到 <code>speculation()</code> 中了。随时在真实项目中使用它。</p><h2 id="原生-JS-Promise-的附加内容"><a href="#原生-JS-Promise-的附加内容" class="headerlink" title="原生 JS Promise 的附加内容"></a>原生 JS Promise 的附加内容</h2><p>原生 Promise 对象有一些你可能感兴趣的附加内容：</p><ul><li><p><code>Promise.reject()</code> 返回一个 rejected promise 。</p></li><li><p><code>Promise.resolve()</code> 返回一个 resolved promise 。</p></li><li><p><code>Promise.race()</code> 接收一个 promise 数组 (或任何迭代器) 并且返回第一个 resolved (值) 或 rejected (原因) 的 promise 。</p></li><li><p><code>Promise.all()</code> 接收一个 promise 数组 (或任何迭代器) 并且当迭代器中所有 promises 都 resolved 后返回一个 promise ，或者返回第一个 rejected (原因) 的 promise。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promises 已称为 JavaScript 语法的重要部分，包括用于 ajax 请求的 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">WHATWG Fetch</a> 标准，用于让异步代码看起来像同步代码的 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">Async Functions</a> 标准。</p><p>在撰写本文时 (2017.1.23)，Async functions 还处于第3阶段，但我预测它们很快将成为 JavaScript 中异步编程的一种非常流行，非常有效的解决方案 – 这意味着在不久的将来，学习 promises 对 JavaScript 开发人员来说将变得更加重要。</p><p>例如，如果你正在使用 Redux ，我建议你看下 <a href="">redux-saga</a>：一个用于管理 Redux 中副作用的库，整个文档都依赖于异步函数。</p><p>我希望即使是有着丰富 promise 使用经验的开发人员在阅读完本文之后，能够对 promise 有更好的理解和 promise 是如何工作的，以及更好地去使用 promise 。</p><h2 id="探索-‘Master-the-JavaScript-Interview’-系列"><a href="#探索-‘Master-the-JavaScript-Interview’-系列" class="headerlink" title="探索 ‘Master the JavaScript Interview’ 系列"></a>探索 ‘Master the JavaScript Interview’ 系列</h2><ul><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">What is a Closure?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">What is the Difference Between Class and Prototypal Inheritance?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">What is a Pure Function?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">What is a Function Composition?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">What is a Function Programming?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">What is a Promise?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466" target="_blank" rel="noopener">Soft Skills</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 类继承和原型继承的区别？</title>
      <link href="/2018/08/29/trans-4/"/>
      <url>/2018/08/29/trans-4/</url>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*rtVyaoswTo9iljufAz7Y8A.jpeg" alt="Electric Guitar"></p><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">Master the JavaScript Interview: What’s the Difference Between Class &amp; Prototypal Inheritance?</a></p><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。如果你想从头开始，可以看 <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.6xq65f6f5" target="_blank" rel="noopener">“What is a Closure?”</a> 开始。</p></blockquote><blockquote><p>注意：这篇文章的例子使用的是 ES6。如果你不知从何开始， 可以参阅 <a href="https://medium.com/javascript-scene/how-to-learn-es6-47d9a1ac2620" target="_blank" rel="noopener">“How to Learn ES6”</a></p></blockquote><p>与其他大多数语言不同的是， JavaScript 的对象系统是基于 <strong>原型(prototypes)</strong> ， 而不是 <strong>类(classes)</strong> 。不幸的是，大多数 JavaScript 开发人员都不能深入了解 JavaScript 的对象系统，或者不能充分利用它。其他人确实理解，但是希望它表现得更像基于类继承。导致 JavaScript 中的对象系统十分混乱，这意味着 JavaScript 开发者对 <strong>原型(prototypes)和类(classes)</strong> 都要了解。</p><a id="more"></a><h2 id="类继承和原型继承的区别是什么？"><a href="#类继承和原型继承的区别是什么？" class="headerlink" title="类继承和原型继承的区别是什么？"></a>类继承和原型继承的区别是什么？</h2><p>这可能是一个棘手的问题，你可能需要后续的问答来完善这个答案，因此要特别注意了解它们的差异，以及如何利用这些知识来写出更好的代码。</p><p><strong>类继承：类相当于蓝图–对将要创建的对象的描述。</strong></p><p>实例通常是使用构建函数和 <code>new</code> 关键字来创建的。ES6 中新增了 <code>class</code> 关键字可以使用。从技术上来说，像 Java 中的类这个概念在 JavaScript 中是不存在的。而是使用构造函数。ES6 中的 <code>class</code> 关键字就是构造函数的语法糖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> Foo <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中，类继承的实现建立在原型继承之上，但这并不意味着它们做了同样的事情：</p><p>JavaScript 类继承是使用原型链链接子 <code>Constructor.prototype</code> 和父  <code>Constructor.prototype</code> 的委托关系。通常，<code>super()</code>构造器也会被调用。这种机制，形成了<strong>单一继承结构</strong>，并且创建了<strong>面向对象设计的最紧密耦合行为</strong>。</p><blockquote><p><em>“Classes inherit from classes and create subclass relationships: hierarchical class taxonomies.”</em></p></blockquote><blockquote><p><strong>Prototypal Inheritance: A prototype is a working object instance.</strong> Objects inherit directly from other objects.</p></blockquote><p>原型继承模式下，对象实例可以由多个对象源组成，这样使继承更灵活且 [[Prototype]] 委托继承层次浅。换句话说，基于原型继承的面向对象设计不会产生层级分类这样的副作用–这是决定性的区别。</p><p>JavaScript 中的实例通常是通过构造函数，对象字面量或 <code>Object.create()</code> 来创建。</p><blockquote><p><em>“A prototype is a working object instance. Objects inherit directly from other objects.”</em></p></blockquote><h2 id="为什么这个问题很重要？"><a href="#为什么这个问题很重要？" class="headerlink" title="为什么这个问题很重要？"></a>为什么这个问题很重要？</h2><p>继承是代码重用机制的根本：不同对象分享代码的方式。分享代码的方式的重要性是因为如果你弄错了，会产生很多问题，特别是：</p><p><strong>类继承产生的 parent/child 对象分类是一个副作用。</strong></p><p>这些分类几乎不可能适用于所有的新实例，并且基类的广泛使用导致了<strong>脆弱的基类问题</strong>，这导致了修复 bug 的难度。事实上，类继承在面向对象设计中引起了许多众所周知的问题：</p><ul><li><p><strong>紧耦合问题</strong> (类继承是面向对象设计中耦合度最高的)，这导致了下一个问题</p></li><li><p>脆弱基类问题</p></li><li><p>不灵活的层级问题 (新实例最终会导致所有的类都是错误的)</p></li><li><p>必要的重复问题 (由于层次机构不灵活，新的实例通常是通过复制而不是调整现有代码来实现)</p></li><li><p>猩猩/香蕉问题 (你需要的是一个香蕉，但是得到的是一个拿着香蕉的猩猩以及整个丛林)</p></li></ul><p>我在一个演讲中深入讨论过这其中的一些问题：“Classical Inheritance is Obsolete: How to Think in Prototypal OO”：</p><div class="video-container"><iframe src="//www.youtube.com/embed/lKCCZTUx0sI" frameborder="0" allowfullscreen></iframe></div><p>解决所有问题的方法是选择对象组合而不是类继承。</p><blockquote><p><em>“Favor object composition over class inheritance.”</em><br><em>~ The Gang of Four, <a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=WMUILDJNIUXY4NSH" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object Oriented Software”</a></em></p></blockquote><p>总结：</p><div class="video-container"><iframe src="//www.youtube.com/embed/wfMtDGfHWpA" frameborder="0" allowfullscreen></iframe></div><h2 id="是不是所有的继承都有问题？"><a href="#是不是所有的继承都有问题？" class="headerlink" title="是不是所有的继承都有问题？"></a>是不是所有的继承都有问题？</h2><p>人们说“优先选择对象组合而不是继承”的时候，其实是要表达“优先选择对象组合而不是类继承”(引用自 “Design Patterns” 的原文)。这是面向对象设计的常识。因为类继承有许多缺陷并会导致许多问题。</p><p>当人们谈论类继承时，人们通常会忽略 <strong>class</strong> 这个单词，这看起来好像所有的继承都有问题–但事实并非如此。</p><p>继承是有不同种类的，并且大部分的优秀的。</p><h2 id="原型继承的三种方式"><a href="#原型继承的三种方式" class="headerlink" title="原型继承的三种方式"></a>原型继承的三种方式</h2><p>在我们深入研究其他类型的继承之前，让我们仔细观察一下类继承的含义：</p><script src="//gist.github.com/fe1d8dfd036b43811c16d087d2e7fb8c.js?file=class-inheritance-example.js"></script><p><code>BassAmp</code> 继承于 <code>GuitarAmp</code>， <code>ChannelStrip</code> 继承于 <code>BassAmp</code> 和 <code>GuitarAmp</code>。这是面向对象设计的一个错误示范。channel strip 并不是 guitar amp 的一种，而且它根本不需要 cabinet 这个属性。一个比较好的方法是创建一个新的基类给 amps 和 channel strip 继承，但是这种方法依然有局限。</p><p>最终，新的基类策略也会失效。</p><p>更好的方法是，可以使用对象组合继承你真正需要的东西：</p><script src="//gist.github.com/d1997b0efa3119ec583ad6ff40da79d9.js?file=composition-example.js"></script><p>认真看这段代码，你就会发现：通过对象组合，我们可以确切地保证对象可以按需继承。这和类继承不同。当你继承于一个类，你会继承所有的属性，即使是你不需要的。</p><p>在这一点上，你可能会问自己，“这很好，但是原型在哪里呢？”</p><p>为了理解这一点，你必须了解有三种不同的基于原型的面向对象设计。</p><p><strong>拼接继承 (Concatenative inheritance)</strong>：通过复制源对象的属性直接一个对象继承另一个对象的过程。在 JavaScript 中，源对象的属性通常被称作 <strong>mixins</strong>。从 ES6 开始，JavaScript 使用 <code>Object.assign()</code> 来实现这个过程。在 ES6 之前，通常使用 <strong>Underscore/Lodash</strong> 的 <code>.extend()</code> 和 <strong>jQuery</strong> 的 <code>$.extend()</code> 等来实现。上面的对象组合的例子使用了连接继承。</p><p><strong>原型委托 (Prototype delegation)</strong>：在 JavaScript 中，对象有自己委托的原型，这个原型也有自己委托的原型，以此类推一直到 <code>Object.prototype</code> 作为根原型，这样就形成了一个原型链。如果一个在对象中找不到的属性，可以沿着原型链一直查找。当你使用 <code>new</code> 创建实例以及 <code>Constructor.prototype</code> 连接到这个实例形成链接。你也可以使用 <code>Object.create()</code> 来实现，或者与拼接混用，从而可以把多个原型简化为单一委托，或者在对象创建后进行扩展。</p><p><strong>函数继承 (Functional inheritance)</strong>：在 JavaScript 中，任何函数都可以创建对象。如果这个函数既不是构造函数也不是 <code>class</code>，那就是<strong>工厂函数 (factory function)</strong>。函数继承的原理是通过工厂函数创建对象并通过直接赋予属性(使用连接继承)。Douglas Crockford 创造了这个术语，但在 JavaScript 中已经广泛使用了。</p><p>现在你会意识到，拼接继承是在 JavaScript 中实现对象组合的秘诀，这使得原型委托和函数继承更加有趣。</p><p>大多数人提到 JavaScript 的面向对象设计时，首先想到的是原型委托。现在你会发现他们错过了很多。原型委托不是类继承的最佳替换，对象组合才是。</p><h2 id="为什么对象组合能改避免脆弱基类问题"><a href="#为什么对象组合能改避免脆弱基类问题" class="headerlink" title="为什么对象组合能改避免脆弱基类问题"></a>为什么对象组合能改避免脆弱基类问题</h2><p>要搞清脆弱基类这个问题，首先你要理解这个问题是如何形成的：</p><ol><li><code>A</code> 是基类</li><li><code>B</code> 继承于 <code>A</code></li><li><code>C</code> 继承于 <code>B</code></li><li><code>D</code> 继承于 <code>B</code></li></ol><p><code>C</code> 调用 <code>super</code>， 会执行 <code>B</code> 中的代码，<code>B</code> 调用 <code>super</code>， 会执行 <code>A</code> 中的代码。</p><p><code>A</code> 和 <code>B</code> 中包含了 <code>C</code> 和 <code>D</code> 不需要的特性。 <code>D</code> 是一个新实例， <code>C</code> 和 <code>D</code> 在 <code>A</code> 初始化的代码有少许不同。所以萌新开发者会去调整 <code>A</code> 的初始化代码。由于依赖于之前 <code>A</code> 中的代码被修改了，尽管 <code>D</code> 正常工作了，但是 <code>C</code> 被破坏了。</p><p>我们有不同的方式可以从 <code>A</code> 和 <code>B</code> 中得到 <code>C</code> 和 <code>D</code> 需要的属性。<code>C</code> 和 <code>D</code> 并不需要 <code>A</code> 和 <code>B</code> 的所有特性。它们只想继承一些已经定义在 <code>A</code> 和 <code>B</code> 中的属性。但是通过 <code>super</code> 来实现继承，这不是选择性的继承而是继承所有的属性。</p><blockquote><p><em>“…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. <strong>You wanted a banana but what you got was a gorilla holding the banana</strong> and the entire jungle.” ~ Joe Armstrong — “Coders at Work”</em></p></blockquote><h3 id="使用组合-Composition"><a href="#使用组合-Composition" class="headerlink" title="使用组合 (Composition)"></a>使用组合 (Composition)</h3><p>想象下你拥有的是特性 (features) 而不是类 (classes)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat1, feat2, feat3, feat4</span><br></pre></td></tr></table></figure><p><code>C</code> 需要 <code>feat1</code> 和 <code>feat3</code>， <code>D</code> 需要 <code>feat1</code>，<code>feat2</code>，<code>feat4</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = compose(feat1, feat3)</span><br><span class="line"><span class="keyword">const</span> D = compose(feat1, feat2, feat4)</span><br></pre></td></tr></table></figure><p>现在你发现，<code>D</code> 需要 <code>feat1</code> 的行为有些许不同。这并不需要改变 <code>feat1</code>，而是创造一个自定义的 <code>feat1</code> 并且使用它。不需要改变 <code>feat2</code> 和 <code>feat4</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> D = compose(custom1, feat2, feat4)</span><br></pre></td></tr></table></figure><p><code>C</code> 不会受到影响。</p><p>类继承无法实现这一点的原因是，当你使用类继承时，你得到的是类这个整体。</p><p>如果你为了适配新的实例，要么复制现有类的一部分（必然性重复问题），要么重构依赖于现有类的所有内容使得修改有的类适配于新的实例，这会导致脆弱基类问题。</p><p>对象组合可以避免这两个问题。</p><h3 id="你自认为了解原型，但是…"><a href="#你自认为了解原型，但是…" class="headerlink" title="你自认为了解原型，但是…"></a>你自认为了解原型，但是…</h3><p>如果你的所学是，构建类或者构造函数而不是原型继承。那么你学到的是使用原型来模仿类继承。了解更多 – <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">Common Misconceptions About Inheritance in JavaScript</a></p><p>在 JavaScript 中，长久以来类继承寄生在非常丰富灵活的原生的原型继承之上， ES6 以来的 <code>class</code> 也是一样，当你使用类继承，原型继承的强大能力和灵活性都不能得到应用。事实上，你正在把自己圈在角落并且选择所有的类继承和它所带来的问题。</p><blockquote><p><em>Using class inheritance in JavaScript is like driving your new Tesla Model S to the dealer and trading it in for a rusted out 1983 Ford Pinto.</em></p></blockquote><h2 id="Stamps：可组合的工厂函数"><a href="#Stamps：可组合的工厂函数" class="headerlink" title="Stamps：可组合的工厂函数"></a>Stamps：可组合的工厂函数</h2><p>大多数情况下，通过多个工厂函数实现对象组合：工厂函数是用来创建对象的。如果工厂函数也可以组合呢？它被称作 (Stamps) – <a href="https://github.com/stampit-org/stamp-specification" target="_blank" rel="noopener">The Stamp Specification</a></p><h2 id="探索-‘Master-the-JavaScript-Interview’-系列"><a href="#探索-‘Master-the-JavaScript-Interview’-系列" class="headerlink" title="探索 ‘Master the JavaScript Interview’ 系列"></a>探索 ‘Master the JavaScript Interview’ 系列</h2><ul><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">What is a Closure?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">What is the Difference Between Class and Prototypal Inheritance?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">What is a Pure Function?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">What is a Function Composition?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">What is a Function Programming?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">What is a Promise?</a></p></li><li><p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466" target="_blank" rel="noopener">Soft Skills</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是闭包（Closure）？</title>
      <link href="/2018/08/27/trans-3/"/>
      <url>/2018/08/27/trans-3/</url>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*J-jjDviwGUfzka1HX5LG9A.jpeg" alt="closure"></p><blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Closure?</a></p></blockquote><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><p>什么是闭包通常是我 JavaScript 面试的第一个和最后一个问题。坦白说，如果你不理解闭包你就不能深入掌握 JavaScript。</p><a id="more"></a><p>你别含糊其辞，但是你真的理解如何构建一个严肃的 JavaScript 程序吗？你真的明白发生了什么，或者程序是如何运行的。我有疑虑，如果不知道这个问题的答案是一个非常危险的信号。</p><p>你不仅应该知道闭包的机制，还应该知道闭包为什么重要，并且可以轻易回答闭包的几个应用场景。</p><p>在 JavaScript 中，闭包通常用于数据私有，事件处理和毁掉函数，以及 <a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.l4b6l1i3x" target="_blank" rel="noopener">偏函数应用(Partial Applications)和柯里化(Currying)</a> ,还有其他函数式编程模式。</p><p>我不在乎面试者是否知道 “closure” 这个单词或它的专业定义。我只想知道他们是否知道闭包的基本原理。如果不知道，通常代表他们没有很多构建真正 JavaScript 应用的经验。</p><blockquote><p><em>If you can’t answer this question, you’re a junior developer. I don’t care how long you’ve been coding.</em></p></blockquote><blockquote><p>That may sound mean, but it’s not. What I mean is that most competent interviewers will ask you what a closure is, and most of the time, getting the answer wrong will cost you the job. Or if you’re lucky enough to get an offer anyway, it will cost you potentially tens of thousands of dollars per year in pay because you’ll be hired as a junior instead of a senior level developer, regardless of how long you’ve been coding.</p></blockquote><p>快速准备一下：“你能说出两种闭包的通用场景？”</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是绑定函数和引用其周围的状态的组合 <strong>(词法环境 lexical environment)</strong>。换句话说，闭包可以让内部函数访问外部函数的作用域。在 JavaScript 中，每次创建函数时，都会在创建函数时创建闭包。</p><p>使用闭包，只需在另一个函数内定义一个函数并且公开出来。通过返回或传递给另一个函数来公开这个函数。</p><p>内部函数可以访问外部函数作用域的变量，即使外部函数完成返回了。</p><h2 id="使用闭包-例子"><a href="#使用闭包-例子" class="headerlink" title="使用闭包 (例子)"></a>使用闭包 (例子)</h2><p>闭包通常用于对象数据私有化。数据私有是让我们能够面向接口编程而不是实现编程的基础。这是可以帮助我们构建强壮软件的一个重要概念。因为实现细节比接口更容易改变。</p><blockquote><p><em>“Program to an interface, not an implementation.”</em></p></blockquote><blockquote><p><em><a href="http://www.amazon.com/gp/product/B000SEIBB8?ie=UTF8&amp;camp=213733&amp;creative=393177&amp;creativeASIN=B000SEIBB8&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=CSQYBHTUP625XI4T" target="_blank" rel="noopener">Design Patterns: Elements of Reusable Object Oriented Software</a></em></p></blockquote><p>在 JavaScript 中，闭包是用于实现数据私有的主要机制。当你使用闭包实现数据私有时，被封装的数据只能在闭包函数作用域中使用。你无法绕过对象 <strong>被授权的方法(privileged methods)</strong> 在外部访问这些数据。任何在闭包作用域内定义的公开方法都是特权方法。例如：</p><script src="//gist.github.com/6fb9890ce1ffb14bad9f059adc4a2f0d.js?file=data-privacy-example.js"></script><p>在上面的例子中，’.get()’ 方法定义在 <code>getSecret()</code> 方法的作用域内，它可以访问<code>getSecret()</code> 中的任何变量，于是它就是一个被授权的方法。在这个例子中，它可以访问参数 <code>secret</code>。</p><p>对象不是产生数据私有的唯一方法。闭包也可以用于创建有状态函数，其返回值可能受其内部状态影响，e.g.:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secret = <span class="function"><span class="params">msg</span> =&gt;</span> () =&gt; msg;</span><br></pre></td></tr></table></figure><script src="//gist.github.com/b16af817ec53ad8bbb49875aa4795e74.js?file=secret.js"></script><p>在函数式编程中，闭包通常用于偏函数应用和柯里化。为了理解这些，我们需要一些定义：</p><p><strong>应用程序</strong>：一个应用给定参数并产生一个返回值的过程。</p><p><strong>偏函数应用</strong>：一个应用部分参数的函数的过程。并返回一个新函数作为参数。换句话说，应用一个具有多个参数的函数并返回一个较少参数的函数。偏函数应用先使用一个或部分参数在将要返回的函数中，等待返回的函数调用剩余的参数来完成整个应用。</p><p>偏函数应用利用闭包作用域来提前使用部分参数。你可以实现一个通用函数来赋予指定函数部分参数。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">partialApply(targetFunction: <span class="built_in">Function</span>, ...fixedArgs: Any[]) =&gt;</span><br><span class="line">  functionWithFewerParams(...remainingArgs: Any[])</span><br></pre></td></tr></table></figure><p>如果你想进一步了解，请看 <a href="https://github.com/ericelliott/rtype#reading-function-signatures" target="_blank" rel="noopener">Rtype: Reading Function Signatures</a></p><p>利用一个接受任意参数的函数，赋予我们指定的参数。并且返回一个新函数接受剩余的参数。</p><p>这个例子将会帮助你理解。你现在又一个 求两个数的和 的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><p>现在你想要一个 10 加任意数字的函数。我们称它为 <code>add10()</code>。<code>add10(5)</code> 的结果应该是15. <code>partialApply()</code> 函数将会实现它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add10 = partialApply(add, <span class="number">10</span>)</span><br><span class="line">add10(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，’10‘ 作为 <strong>固定参数(fixed parameter)</strong> 通过闭包作用域提前赋予给 <code>add()</code>, 从而我们获得了 <code>add10()</code>。</p><p>让我们来看一下如何实现 <code>partialApply()</code>：<br><br><script src="//gist.github.com/543442825c8519c03e19584daab41bc9.js?file=partial-apply.js"></script></p><p>如你所见，它只是简单地返回一个函数，这个函数通过闭包访问了传给 <code>partialApply()</code> 函数的 fixedArgs 参数。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是函数式编程（Functional Programming）？</title>
      <link href="/2018/08/24/trans-2/"/>
      <url>/2018/08/24/trans-2/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">Master the JavaScript Interview: What is Functional Programming?</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/1600/1*1OxglOpkZHLITbIKEVCy2g.jpeg" alt="Structure Synth — Orihaus (CC BY 2.0)"></p><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><p>函数式编程已经成为了 JavaScript 世界的一个热门话题。仅仅在几年前，甚至只有很少 JavaScript 开发者知道函数式编程，但是在过去的3年中我看到了大量使用函数式编程思维构建的应用。</p><a id="more"></a><p><strong>函数式编程</strong> （简称 FP）是通过纯函数组合来构建软件，避免<strong>共享状态(shared state)</strong>， <strong>可变数据(mutable data)</strong>，以及<strong>副作用(side-effects)</strong>。函数式编程是<strong>声明式(declarative)</strong>的而不是<strong>命令式(imperative)</strong> 的，应用程序状态通过纯函数而改变。与面向对象编程相比，应用程序的状态和对象的方法是共享和共存的。</p><p>函数式编程是一种<strong>编程范式(programming paradigm)</strong>，意思是它是一种基于一些基本的，确定的原则来思考软件构建的一种方式。编程范式的其他例子有包括面向对象编程和过程编程。</p><p>与命令式和面向对象代码相比，函数式的代码通常更简洁，可预测和易于测试。但是如果你不熟悉函数式编程以及与之相关的常见模式，它看起来更愚钝，而且对于新手来说相关文献也难以理解。</p><p>如果你使用谷歌搜索函数式编程，你很快会发现学术术语的高墙，对于初学者来说会非常令人生畏。函数式编程有一个恐怖的学习曲线。但是如果你已经使用了 JavaScript 一段时间，你很可能在真实编程中是用了很多函数式编程的概念和工具。</p><p><strong><em>Don’t let all the new words scare you away. It’s a lot easier than it sounds.</em></strong></p><p>最困难的部分是关于不熟悉的词汇的思维转变。在你掌握函数式编程的意义之前，你还需要理解下面这些定义：</p><ul><li><p>纯函数</p></li><li><p>函数组合</p></li><li><p>避免共享状态</p></li><li><p>避免可变状态</p></li><li><p>避免副作用</p></li></ul><p>换句话说，如果你想真正理解函数式编程的含义，你必须首先理解这些核心概念。</p><h2 id="纯函数-Pure-Function"><a href="#纯函数-Pure-Function" class="headerlink" title="纯函数 (Pure Function)"></a>纯函数 (Pure Function)</h2><p>纯函数是：</p><ul><li><p>输入相同，输出一定相同</p></li><li><p>没有副作用</p></li></ul><p>纯函数具有很多在函数式编程中非常重要的属性，包括<strong>引用透明</strong> （你可以在不改变程序的定义下替换函数调用及返回值）。更多细节 – <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">“What is a Pure Function?”</a></p><h2 id="函数组合-Function-Composition"><a href="#函数组合-Function-Composition" class="headerlink" title="函数组合 (Function Composition)"></a>函数组合 (Function Composition)</h2><p><strong>函数组合</strong>是组合两个或多个函数以产生新的函数或执行某些计算的程序。例如 <code>f.g</code> 等同于 JavaScript 中的 <code>f(g(x))</code>。理解函数组合是了解如何使用函数式编程构建软件的重要一步。补充学习 – <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">“What is Function Composition?”</a></p><h2 id="共享状态-Shared-State"><a href="#共享状态-Shared-State" class="headerlink" title="共享状态 (Shared State)"></a>共享状态 (Shared State)</h2><p><strong>共享状态</strong> 是存在于共享作用域的任何变量，对象或内存空间，或者是在不同作用域之间传递的一个对象的属性。共享作用域可以是全局或闭包。通常，在面向对象编程中，不同作用域直接通过想另一对象添加属性来进行共享对象。</p><p>例如，在电子游戏中又一个主对象，这个主对象将游戏角色和物品作为属性。函数式编程避免了共享状态，依赖于不可变数据结构或从已有数据计算而得到的新数据。有关软件函数如何处理软件状态的更多详细信息 – <a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10 Tips for Better Redux Architecture”</a></p><p>共享状态的问题在于，为了理解函数的结果，你必须要了解所有函数使用或影响每个共享变量的完整历史记录。</p><p>想象一下，你有一个需要保存的用户对象。<code>saveUser()</code> 是一个向服务器发送请求的 API。当 <code>saveUser()</code> 执行时，用户使用 <code>updateAvatar()</code> 函数更改个人资料图片并触发了另一个 <code>saveUser()</code> 函数。保存时，为了保持与服务器同步或响应其他 API 调用，服务器返回一个用户对象来替换内存中的对象。</p><p>不幸的是，第二个响应在第一个响应之前被接收，所以当第一个（现在是过时的）响应返回时，内存中的旧对象已经被覆盖了图片的对象替换了。这是一个条件竞争的例子–一个与共享状态相关的常见错误。</p><p>另一个与共享状态的常见问题是，更改函数调用顺序可能会导致级联错误，因为作用于共享状态的函数与调用时机有关：</p><script src="//gist.github.com/23f93290914912816211c9041ddd856d.js?file=timing-dependency.js"></script><p>当你避免了共享状态，函数调用的时机和顺序不会改变返回结果。使用纯函数，相同的输入，总能得到相同的输出。这使得函数调用完全独立于其他函数调用，这从根本上简化了修改和重构。一个函数的修改或函数调用的时机不会改变或破坏程序的其他部分。</p><script src="//gist.github.com/a9768374c9084bb3cae6d64b5827024d.js?file=no-timing-dependency.js"></script><p>上面的例子中，我们使用 <code>Object.assign()</code> 并传入一个空对象作为第一个参数来复制 x 的属性而不是直接修改它。在这种情况下，它相当于从头创建了一个新对象。 <code>Object.assign()</code> 是 JavaScript 中复制已存在的属性来创建对象的常用模式而不是使用直接修改，我们在第一个例子中演示了直接修改赋值。</p><p>如果你仔细观察了这个例子中的 <code>console.log()</code> 语句，你应该注意到我已经提到过的事情：函数组合。回想之前提到的，函数组成如下所示： <code>f(g(x))</code> 。我们使用了 <code>x1()</code> 和 <code>x2()</code> 替换了 <code>f()</code> 和 <code>g()</code>。</p><p>如果你改变了组合的顺序，输出会发生改变。操作顺序依然是一个麻烦。 <code>f(g(x))</code> 不总是等同于 <code>g(f(x))</code>，但是函数外部的变量发生了什么是无所谓的–这个是重点。使用非纯函数，除非你知道函数使用或影响的每个变量的完整历史记录，否则无法完全理解函数的作用。</p><p>移除函数调用顺序的依赖，并且消除整个类潜在的错误。</p><h2 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性 (Immutability)"></a>不可变性 (Immutability)</h2><p><strong>不可变(immutable)</strong> 对象指的是一个对象在创建后无法修改。反过来说，一个 <strong>可变(mutable)</strong> 对象指的是一个对象在创建后可以修改。</p><p><strong>不可变性(Immutability)</strong> 是函数式编程的一个核心概念，因为没有她，你的程序中的数据流是有损的。状态历史被丢弃，你的软件会蔓延奇怪的错误。关于不可变性的更多信息 – <a href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd" target="_blank" rel="noopener">“The Dao of Immutability.”</a></p><p>在 JavaScript 中，重要的是不要将 <code>const</code> 和不可变性混淆。<code>const</code> 创建了一个变量和变量名的绑定，在创建后无法重新赋值。<code>const</code> 不是创建了一个不可变对象。你无法修改绑定引用的对象，但可以修改对象的属性，也就是说这个 <code>const</code> 创建的绑定是可变的。</p><p>不可变对象是从根本上无法修改的。你可以深度冻结一个对象是这个值无法修改。JavaScript 有一个方法可以冻结对象的一层：</p><script src="//gist.github.com/e01b161efad12f9615fba55b15c684f7.js?file=frozen-objects.js"></script><p>但是冻结的对象只是表面上的不可变。例如，下面这个对象是可变的：</p><script src="//gist.github.com/18585681ea1079101307fa269ec4716c.js?file=frozen-not-immutable.js"></script><p>如你所见，冻结对象的顶层原始属性不能修改，但任何是对象的属性（包括数组等）仍然可以修改。所以，即使冻结对象也不是不可变的，除非你遍历这个对象数并冻结每个对象属性。</p><p>在许多函数式编程语言中，有一种特殊的不可变数据结构称为 <strong>trie 数据结构</strong>，它们被有效地深度冻结。意味着任何层次的属性都无法修改。</p><p>Tries 使用 <strong>结构共享(structural sharing)</strong> 被复制过的不可变对象的所有部分是共享引用内存位置的，这样可以减少使用内存空间，并且可以显著提高某些操作的性能。</p><p>例如，你可以在对象树的根部标识进行比较。如果标识相同，就不必遍历整个树来检查差异。</p><p>JavaScript 中有几个库利用了 tries，包括 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a> 和 <a href="https://github.com/swannodette/mori" target="_blank" rel="noopener">Mori</a>.</p><p>我已经对两者进行了实验，并且倾向于在需要大量不可变状态的大型项目中使用 Immutable.js 。有关更多信息 – <a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10 Tips for Better Redux Architecture”</a></p><h2 id="副作用-Side-Effects"><a href="#副作用-Side-Effects" class="headerlink" title="副作用 (Side Effects)"></a>副作用 (Side Effects)</h2><p>副作用是除了被调用函数的返回值外还有应用程序状态的更改。副作用包括：</p><ul><li><p>修改了任何外部变量或对象属性（e.g., 全局变量或者在父函数作用域链的变量）</p></li><li><p>控制台日志</p></li><li><p>屏幕输出</p></li><li><p>写入文件</p></li><li><p>写入网络</p></li><li><p>触发任何外部进程</p></li><li><p>调用任何其他函数</p></li></ul><p>函数式编程大多避免了副作用，这使得程序更易理解，也更易测试。</p><p>Haskell 和其他函数式语言经常使用 <strong><a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">monads</a></strong> 来隔离和封装来自纯函数的副作用。</p><p>你现在需要知道的是，具有副作用的操作需要和软件的其他部分隔离。如果将副作用和程序逻辑其余部分分开，你的软件将更容易扩展，重构，调试，测试和维护。</p><p>这就是大部分前端框架鼓励用户将状态和组件渲染分开，松耦合的原因。</p><h2 id="高阶函数的可重用性-Reusability-Through-Higher-Order-Functions"><a href="#高阶函数的可重用性-Reusability-Through-Higher-Order-Functions" class="headerlink" title="高阶函数的可重用性 (Reusability Through Higher Order Functions)"></a>高阶函数的可重用性 (Reusability Through Higher Order Functions)</h2><p>函数式编程倾向于复用一组通用的工具函数来处理数据。面向对象编程倾向于方法和数据共存在对象中。这些方法只能处理专门设计的数据，并且通常只能操作同一实例的数据。</p><p>在函数式编程中，所有类型的数据都是公平的。同一个工具函数 <code>map()</code> 可以处理对象，字符串，数字或其他任何类型的数据，因为它将函数作为处理给定类型数据的一个参数。FP 使用高阶函数作为通用技巧。</p><p>JavaScript 的 <strong>头等函数(First Class Functions)</strong> ,允许将函数作为数据。将函数作为变量，参数或返回值等等。。。</p><p><strong>高阶函数(Height Order Function)</strong>, 将函数作为参数或返回值，或两者都有。高阶函数通常用于：</p><ul><li><p>抽象或隔离动作，结果，或者通过回调，promise，monads 等等来实现异步函数。</p></li><li><p>创建可以处理各种类型数据的工具函数</p></li><li><p>将函数作为参数或创建柯里化函数，目的是复用或函数组合</p></li><li><p>输入一组函数并返回这些函数的组合</p></li></ul><h2 id="容器，函子，列表和流-Containers-Functors-Lists-and-Streams"><a href="#容器，函子，列表和流-Containers-Functors-Lists-and-Streams" class="headerlink" title="容器，函子，列表和流(Containers, Functors, Lists, and Streams)"></a>容器，函子，列表和流(Containers, Functors, Lists, and Streams)</h2><p>函子是可以映射的。换句话说，他是一个拥有使用函数替换其中的值的接口的容器。当你看到函子时，你应该想到“可映射的”。</p><p>之前我们学习了可以处理各种数据类型的工具函数 <code>map()</code>。它提供一种映射操作作为函子 API。<code>map()</code> 使用的流程控制操作利用了这个接口。在 <code>Array.prototype.map()</code> 这种情况下，容器时数组，但是只要支持 mapping API，其他的数据结构也可以作为函子。</p><p>让我们来看看 <code>Array.prototype.map()</code>，它时如何允许你从映射工具中抽象数据类型，使 <code>map()</code> 可用于任何数据类型。我们将创建一个简单的 <code>double()</code> 映射，将传入的值双倍输出。</p><script src="//gist.github.com/3e62d5c301c70a6c29eaaafe15009405.js?file=double-mapping.js"></script><p>如果我们想要在游戏中的点数翻倍，需要怎么做？我们所要做的就是传入 <code>map()</code> 的 <code>double()</code> 函数进行微妙的修改，并且一切正常：</p><script src="//gist.github.com/0238c8e291b2c2c5a2f33d3333c51fb2.js?file=map-custom-data-type.js"></script><p>在函数式编程中，为了操作任意数量的不同数据类型，使用如同函子和高阶函数等的抽象的通用工具函数是一个重要概念。你可以看到类似的概念 – <a href="https://github.com/fantasyland/fantasy-land" target="_blank" rel="noopener">all sorts of different ways</a></p><p><em>“A list expressed over time is a stream.”</em></p><p>现在你需要知道的是，数组和函子不是容器应用中容器和值的唯一概念。例如，数组只是事物列表。随时间改变的列表是流，所以你可以使用相同类型的方法来处理传入事件的流，当你真正开始用 FP 构建软件时，你会看到很多东西。</p><h2 id="声明式-vs-命令式-Declarative-vs-Imperative"><a href="#声明式-vs-命令式-Declarative-vs-Imperative" class="headerlink" title="声明式 vs 命令式(Declarative vs Imperative)"></a>声明式 vs 命令式(Declarative vs Imperative)</h2><p>函数式编程是一种声明式范式，意味着程序逻辑不需要确定流程控制来表达。</p><p><strong>命令式(Imperative)</strong> 程序使用特定步骤来获得需要的结果 – <strong>流程控制(flow control)</strong>：<strong>如何(how)</strong> 去做。</p><p><strong>声明式(Declarative)</strong> 程序抽象流程控制 – <strong>做什么(what)</strong>。抽象做的方式。</p><p>例如，命令式映射传入一个数字数组，返回一个这个数组且其中的值都加倍：</p><script src="//gist.github.com/8b5c98dc2b324ee8cfea451762d07bfe.js?file=imperative-example.js"></script><p>这个声明式映射做了相同的事情，但是使用了 <code>Array.prototype.map()</code> 工具来抽象流程控制，这使你更清楚地表达数据流：</p><script src="//gist.github.com/a3fe04fe9f099cb54492bedea6a33fc1.js?file=declarative-example.js"></script><p>命令式代码经常使用语句。语句是执行某些操作的一段代码。常用语句包括 <code>for</code>， <code>if</code>， <code>switch</code>， <code>throw</code> 等等。</p><p>声明式代码更多依赖于表达式。表达式是一段计算一些值的代码。表达式通常组合函数调用，值和操作来计算得出结果。</p><p>下面都是表达式的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">2</span></span><br><span class="line">doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通常，表达式在代码中作为变量，函数返回值或函数参数。表达式在赋值，返回或者出入之前，需要先计算出它的结果。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>函数式编程的偏好：</p><ul><li><p>纯函数而不是共享状态和副作用</p></li><li><p>不可变性高于可变数据</p></li><li><p>函数组合高于命令式的流程控制</p></li><li><p>很多使用高阶函数处理各种数据类型的通用的，可复用的工具函数而不是只能处理同一对象数据的方法</p></li><li><p>声明式而不是命令式 (做什么，而不是怎么做)</p></li><li><p>表达式而不是语句</p></li><li><p>容器 &amp; 高阶函数优于特定多态(ad-hoc polymorphism)</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】JavaScript 工程师需要知道的十道面试题</title>
      <link href="/2018/08/24/trans-1/"/>
      <url>/2018/08/24/trans-1/</url>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*RPKQq3zYYddwJf9rSeQ4Dg.jpeg" alt="Bruce Lee"></p><blockquote><p>原文：<a href="https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95" target="_blank" rel="noopener">10 Interview Questions Every JavaScript Developer Should Know</a></p></blockquote><h2 id="你能说出两个对-JavaScript-应用程序开发人员很重要的编程范式吗？"><a href="#你能说出两个对-JavaScript-应用程序开发人员很重要的编程范式吗？" class="headerlink" title="你能说出两个对 JavaScript 应用程序开发人员很重要的编程范式吗？"></a>你能说出两个对 JavaScript 应用程序开发人员很重要的编程范式吗？</h2><p>JavaScript 是一个多范式语言，通过 <strong>OOP</strong> （面向对象编程）和 <strong>函数式</strong> 编程使其支持 <strong>命令式/过程式</strong> 编程。JavaScript 支持以原型链继承方式的 OOP。</p><a id="more"></a><h3 id="加分点："><a href="#加分点：" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>原型继承 （或者： 原型， OLOO）</p></li><li><p>函数式编程 （或者： 闭包，头等函数，lambdas）</p></li></ul><h3 id="减分点："><a href="#减分点：" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>不知道编程范式是什么，没有提到基于原型的面向对象或函数式编程</li></ul><h3 id="补充学习："><a href="#补充学习：" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</li><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</li></ul><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>函数式编程通过组合数学函数来生成程序，并且避免共享状态和可变数据。Lisp （1958年指定） 是最早支持函数式编程的语言之一，并且深受 lambda 演算的启发。至今 Lisp 以及很多衍生语言仍在普遍使用。</p><p>函数式编程是 JavaScript 的一个基本概念（JavaScript 的两大支柱之一）。ES5 JavaScript 添加了一些常用工具方法。</p><h3 id="加分点：-1"><a href="#加分点：-1" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>纯函数/函数纯度</p></li><li><p>避免副作用</p></li><li><p>简单函数组合</p></li><li><p>函数式语言的例子：Lisp，ML，Haskell，Erlang，Clojure，Elm，F Sharp，OCaml 等等。。。</p></li><li><p>提及支持函数式编程的特性：头等函数，高阶函数，函数作为参数/值。</p></li></ul><h3 id="减分点：-1"><a href="#减分点：-1" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>没有提及纯函数/避免副作用</p></li><li><p>不能举出函数式编程语言的例子</p></li><li><p>不知道 JavaScript 作为函数式编程特性</p></li></ul><h3 id="补充学习：-1"><a href="#补充学习：-1" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</p></li><li><p><a href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd" target="_blank" rel="noopener">The Dao of Immutability</a></p></li><li><p><a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea" target="_blank" rel="noopener">Composing Software</a></p></li><li><p><a href="http://haskell.cs.yale.edu/wp-content/uploads/2015/03/HSoM.pdf" target="_blank" rel="noopener">The Haskell School of Music</a></p></li></ul><h2 id="类继承和原型继承之间有什么区别？"><a href="#类继承和原型继承之间有什么区别？" class="headerlink" title="类继承和原型继承之间有什么区别？"></a>类继承和原型继承之间有什么区别？</h2><p><strong>类继承：</strong> 实例继承自类（如蓝图–类的描述），并创建子类关系：层级分类。实例通常对构造函数使用‘new’关键字进行实例化。类继承可以使用 ES6 中的 ‘class’ 关键字声明。</p><p><strong>原型继承：</strong> 实例直接继承于其他对象。实例通常使用工厂函数或 ‘Object.create()’ 函数 进行实例化。实例可以由许多不同的对象组成，也可以方便的选择继承对象。</p><blockquote><p>In JavaScript, prototypal inheritance is simpler &amp;<br>more flexible than class inheritance.</p></blockquote><h3 id="加分点：-2"><a href="#加分点：-2" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>类：创建紧耦合或层级/分类</p></li><li><p>原型：提及拼接继承，原型委托，函数继承，对象组合。</p></li></ul><h3 id="减分点：-2"><a href="#减分点：-2" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>没有提及原型继承和组合优于类继承</li></ul><h3 id="补充学习：-2"><a href="#补充学习：-2" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1 — Prototypal OO</a></p></li><li><p><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">Common Misconceptions About Inheritance in JavaScript</a></p></li></ul><div class="video-container"><iframe src="//player.vimeo.com/video/69255635" frameborder="0" allowfullscreen></iframe></div><h2 id="函数式编程和面向对象编程的优缺点是什么？"><a href="#函数式编程和面向对象编程的优缺点是什么？" class="headerlink" title="函数式编程和面向对象编程的优缺点是什么？"></a>函数式编程和面向对象编程的优缺点是什么？</h2><p><strong>OOP 优点：</strong> 容易理解对象的基本概念，并且易于解释方法调用的含义。OOP 倾向于使用命令式风格而不是声明式风格，它类似于计算机遵循的直接指令集。</p><p><strong>OOP 缺点：</strong> 通常依赖于共享状态。对象和行为通常绑定在同一个实体上，这个实体可以由任意数量的函数随机访问，可能导致诸如竞争条件的不期望的行为。</p><p><strong>FP 优点：</strong> 使用函数范式，程序员避免了共享状态和副作用，从而消除由多个函数竞争统一资源所导致的错误。由于具有像 point-free style 的特性，相比于 OOP 函数式倾向于从根本上简化和易于重新组合以获得更通用的可复用代码。</p><p>FP 也倾向于声明式和指称式，它没有详细说明每一步的操作，而是集中精力在 <strong>做什么</strong> ，让底层函数去处理 <strong>如何做</strong> 。这为重构和性能优化留下了巨大的空间，甚至只需修改很少的代码就可以用更高效的算法替换整个算法。</p><p>利用纯函数的计算可以很容易的扩展到跨多处理器或跨分布式计算集群，而不必担心线程资源冲突，条件竞争等。。。</p><p><strong>FP 缺点：</strong> 过度利用 FP 特性（如 point-free style和大型组合）可能会降低可读性，因为生成的代码通常更抽象，更简洁，不具体。</p><p>与函数式编程相比，更多人熟悉 OO 和命令式编程，因此即使是函数式编程中的常见习惯也会让新团队成员感到困惑。</p><p>FP 比 OOP 有更陡峭的学习曲线，因为 OOP 的流行使得 OOP 的学习材料更易于交流，而 FP 更具学术性和正式性。FP 的概念经常被写成来自 lambda 演算，代数和范畴学所使用的习语和符号，所有这些都需要在这些领域的知识基础。</p><h3 id="加分点：-3"><a href="#加分点：-3" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>提及共享状态的问题，不同事件竞争同一资源等等。。。</p></li><li><p>意识到 FP 能够从根本上简化很多应用</p></li><li><p>意识到不同的学习曲线</p></li><li><p>阐明副作用以及它如何影响程序的可维护性</p></li><li><p>意识到高函数式代码基础可能具有陡峭的学习曲线</p></li><li><p>意识到与同等的 FP 代码基础相比，高 OOP 代码基础会难以修改并且非常脆弱。</p></li><li><p>意识到不可变性对程序状态历史的获取和可塑性产生一个极大提高，允许轻松添加诸如无限撤销/重做，倒带/重放，时间旅行调试等功能。不可变性可以在任意编程范式中实现，但共享状态对象使不可变性在 OOP 中的实现变得复杂。</p></li></ul><h3 id="减分点：-3"><a href="#减分点：-3" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>无法列出任一编程范式的缺点–任何一种范式的人都会遇到一些限制。</li></ul><h3 id="补充学习：-3"><a href="#补充学习：-3" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</p></li><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</p></li></ul><h2 id="什么时候类继承是一个合适的选择"><a href="#什么时候类继承是一个合适的选择" class="headerlink" title="什么时候类继承是一个合适的选择"></a>什么时候类继承是一个合适的选择</h2><p>答案是从不，或者几乎从不。一定不能有超过一层的继承。多层类继承是反模式的。多年来我一直在发出这个挑战，我听过的答案都属于几个常见的误解之一。更常见的是，挑战遇见沉默。</p><blockquote><p>“If a feature is sometimes useful<br>and sometimes dangerous<br>and if there is a better option<br>then always use the better option.”<br>~ Douglas Crockford</p></blockquote><h3 id="加分点"><a href="#加分点" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>很少,几乎从不,从不.</p></li><li><p>单一层级有时是可以接受的,一个基于类的框架,例如 React.Component</p></li><li><p>偏爱对象组合高于类继承.</p></li></ul><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习:"></a>补充学习:</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</p></li><li><p><a href="http://davidwalsh.name/javascript-objects" target="_blank" rel="noopener">JS Objects — Inherited a Mess</a></p></li></ul><h2 id="什么时候原型继承是一个合适的选择"><a href="#什么时候原型继承是一个合适的选择" class="headerlink" title="什么时候原型继承是一个合适的选择"></a>什么时候原型继承是一个合适的选择</h2><p>原型继承有不止一个种类</p><ul><li><p><strong>委托</strong> (i.e.,原型链)</p></li><li><p><strong>拼接</strong> (i.e.,mixins, ’Object.assign()‘)</p></li><li><p><strong>函数化</strong> (不要和函数式编程混淆.用于为私有状态/封装创建闭包的函数)</p></li></ul><p>每种类型的原型继承都有自己的一组用例，但它们在组合方式同样有用，它创建了 <strong>has-a</strong> 或 <strong>uses-a</strong> 或 <strong>can-do</strong> 的关系而不是由类继承创建的 <strong>is-a</strong> 的关系.</p><h3 id="加分点-1"><a href="#加分点-1" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>在模块或函数式编程没有提供明显解决方案的情况下</p></li><li><p>当你需要从多个资源组合对象</p></li><li><p>任何你需要继承的时候</p></li></ul><h3 id="减分点"><a href="#减分点" class="headerlink" title="减分点:"></a>减分点:</h3><ul><li><p>不知道何时使用原型</p></li><li><p>没有意识到 mixins 或 ’Object.assign()‘.</p></li></ul><h3 id="补充学习-1"><a href="#补充学习-1" class="headerlink" title="补充学习:"></a>补充学习:</h3><ul><li><a href="http://chimera.labs.oreilly.com/books/1234000000262/ch03.html#chcsrdou100015eilvj6l9inj" target="_blank" rel="noopener">“Programming JavaScript Applications”: Prototypes section</a></li></ul><h2 id="“优先使用对象组合高于类继承”是什么意思"><a href="#“优先使用对象组合高于类继承”是什么意思" class="headerlink" title="“优先使用对象组合高于类继承”是什么意思?"></a>“优先使用对象组合高于类继承”是什么意思?</h2><p>这是  <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object-Oriented Software”</a> 的引用.这意味着代码复用应该是通过将较小的函数组合到新的对象中来实现,而不是通过类的继承来创建新的分类.</p><p>换句话说,要使用 <strong>can-do</strong>, <strong>has-a</strong>,或 <strong>use-a</strong> 关系而不是 <strong>is-a</strong> 关系.</p><h3 id="加分点-2"><a href="#加分点-2" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>避免类继承</p></li><li><p>避免脆弱的基类问题</p></li><li><p>避免紧耦合</p></li><li><p>避免严格分类（强制 is-a 关系最终会在新的使用方案中出错）</p></li><li><p>避免大猩猩香蕉问题（“你想要的是一个香蕉，得到的是拿着香蕉的大猩猩和整个丛林”）</p></li><li><p>使代码更灵活</p></li></ul><h3 id="减分点：-4"><a href="#减分点：-4" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>没有提到上面的任何问题</p></li><li><p>未能阐明组合和类继承的区别，或组合的优点</p></li></ul><h3 id="补充学习：-4"><a href="#补充学习：-4" class="headerlink" title="补充学习："></a>补充学习：</h3><div class="video-container"><iframe src="//www.youtube.com/embed/wfMtDGfHWpA" frameborder="0" allowfullscreen></iframe></div><blockquote><p>Move Over, ‘class’:<br>Composable Factory Functions Are Here</p><footer><strong>Eric Elliott</strong><cite><a href="https://medium.com/p/77f8911c2fee" target="_blank" rel="noopener">Introducing the Stamp Specification</a></cite></footer></blockquote><h2 id="什么是双向数据绑定和单向数据流，他们有何不同？"><a href="#什么是双向数据绑定和单向数据流，他们有何不同？" class="headerlink" title="什么是双向数据绑定和单向数据流，他们有何不同？"></a>什么是双向数据绑定和单向数据流，他们有何不同？</h2><p>双向数据绑定意味着 UI 和数据模型的动态绑定，当 UI 发生变化，数据模型也会发生变化，反之亦然。</p><p>单向数据流意味着数据模型作为数据来源。改变 UI 会触发消息通知把用户意图发送给数据模型（类似 React 中的 “store”）。只有数据模型才能改变应用状态。结果是数据总是向单一方向流动，能够使代码易于理解。</p><p>单向数据流是确定的，而双向绑定可能产生副作用使其难以跟踪和理解。</p><h3 id="加分点：-4"><a href="#加分点：-4" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>Reac 是单向数据流的新典范，所以提及 Reac 是一个好的信号。 + + + Cycle.js 是另外一个流行的单向数据流实现。</p></li><li><p>Angular 是一种使用双向绑定的流行框架</p></li></ul><h3 id="减分点：-5"><a href="#减分点：-5" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>不知道两者的意思。无法阐明两者的区别</li></ul><h3 id="补充学习：-5"><a href="#补充学习：-5" class="headerlink" title="补充学习："></a>补充学习：</h3><div class="video-container"><iframe src="//www.youtube.com/embed/XxVg_s8xAms" frameborder="0" allowfullscreen></iframe></div><h2 id="一体化和微服务架构的优缺点"><a href="#一体化和微服务架构的优缺点" class="headerlink" title="一体化和微服务架构的优缺点"></a>一体化和微服务架构的优缺点</h2><p>一体化架构意味着你的应用代码是紧密结合的，所有组件协同工作，共享内存空间和资源。</p><p>微服务架构意味着你的应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且它们彼此相互独立，甚至可以在不同机器下运行。</p><p><strong>一体化架构优点：</strong> 一体化架构的主要优势是大多数应用程序有大量的交叉点，例如日志，限速以及审查跟踪和 DOS 保护等安全功能。</p><p>当一切都在同一个应用程序中运行时，这样就很容易讲个组件串联起来。</p><p>还有性能优势，因为共享内存比进程间通信 （IPC） 更快。</p><p><strong>一体化架构缺点：</strong> 一体化架构通常是紧耦合的，应用版本迭代杂糅，使得独立扩展和代码可维护性的隔离服务困难。</p><p>一体化结构也难以理解，因为当你查看特定服务或控制器时，可能存在一些不明显的依赖，副作用以及不可思议的问题。</p><p><strong>微服务架构优点：</strong> 微服务架构通常有更好的组织结构，因为每个部分有自己特定的功能，且不需要关心其他部分的功能。为不同应用服务进行重构和重新配置的解藕服务也更简单。（例如同时提供给网页客户端和开放 API 的服务）</p><p>有于微服务架构的组织方式，它还有性能优势，因为可以隔离热服务并且将其扩展为独立于应用程序的其余部分。</p><p><strong>微服务架构缺点：</strong> 当你构建一个新的微服务架构时，你可能会发现很多在设计时没有预料到的跨组件问题。一体化结构可以轻松地通过共享方式或者中间件来处理跨组件问题。</p><p>在微服务架构中，隔离组件之间通信的开销，封装的组件在另外一个服务层可以让所有路由通过。</p><p>最后，一体化架构也需要外部服务来处理组间通信，但一体化架构可以把这个这个工作成本延迟到项目更加成熟的时候。</p><p>微服务经常部署在它们自己的虚拟机或容器里，导致 VM 竞争的激增。这些任务经常通过容器管理工具自动完成。</p><h3 id="加分点：-5"><a href="#加分点：-5" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>倾向于微服务架构，尽管微服务架构初始成本更高。意识到从长远看微服务性能好易扩展。</p></li><li><p>关于微服务架构和一体化架构的实用性。在构建程序方面，微服务在代码级别相互隔离，一体化在开始时就容易捆绑在一起。微服务的高成本可以延迟到更加成熟的时候。</p></li></ul><h3 id="减分点：-6"><a href="#减分点：-6" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>不知道一体化和微服务之间的差别</p></li><li><p>对微服务架构额外高成本不清楚或一些不切实际的想法</p></li><li><p>对微服务架构， IPC （夸进程通信）和网络通信的额外成本不清楚</p></li><li><p>对微服务架构过于消极，不能明确表达如何通过结偶一体化架构来轻松分割成微服务</p></li><li><p>低估了独立可扩展的微服务架构的优势</p></li></ul><h2 id="什么是异步编程，为什么它在-JavaScript-中很重要？"><a href="#什么是异步编程，为什么它在-JavaScript-中很重要？" class="headerlink" title="什么是异步编程，为什么它在 JavaScript 中很重要？"></a>什么是异步编程，为什么它在 JavaScript 中很重要？</h2><p>同步编程意味着，除了条件语句和函数调用，代码从上到下依次执行，例如网络请求和磁盘 I/O 这样长时间的任务会造成阻塞。</p><p>异步编程意味着引擎运行在时间循环上。当需要阻塞操作时，请求开始后，代码继续运行不需要等待请求结果。当响应准备好，触发中断，导致事件处理运行，控制器在其后执行。通过这种方式，单线程就可以处理并发操作了。</p><p>用户交互本质上是异步的，需要花费大部分时间等待用户输入中断事件循环触发事件回调。</p><p>Node 默认时异步的，这意味着服务方式大致相同，循环等待网络请求，在处理第一个请求的同时接收更多到来的请求。</p><p>异步在 JavaScript 中时非常重要的，因为他非常适合用户交互，并且有利于提高服务器的性能。</p><h3 id="加分点：-6"><a href="#加分点：-6" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>知道什么是阻塞，以及性能的意义</p></li><li><p>知道事件回调，以及为什么对用户界面交互很重要</p></li></ul><h3 id="减分点：-7"><a href="#减分点：-7" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>不熟悉异步或同步</p></li><li><p>无法表达用户交互和异步对性能的影响</p></li></ul>]]></content>
      
      
    </entry>
    
  
  
</search>
