<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【译】精通 JavaScript： 什么是闭包（Closure）？</title>
      <link href="/2018/08/27/trans-3/"/>
      <url>/2018/08/27/trans-3/</url>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*J-jjDviwGUfzka1HX5LG9A.jpeg" alt="closure"></p><blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Closure?</a></p></blockquote><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><p>什么是闭包通常是我 JavaScript 面试的第一个和最后一个问题。坦白说，如果你不理解闭包你就不能深入掌握 JavaScript。</p><a id="more"></a><p>你别含糊其辞，但是你真的理解如何构建一个严肃的 JavaScript 程序吗？你真的明白发生了什么，或者程序是如何运行的。我有疑虑，如果不知道这个问题的答案是一个非常危险的信号。</p><p>你不仅应该知道闭包的机制，还应该知道闭包为什么重要，并且可以轻易回答闭包的几个应用场景。</p><p>在 JavaScript 中，闭包通常用于数据私有，事件处理和毁掉函数，以及 <a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.l4b6l1i3x" target="_blank" rel="noopener">偏函数应用(Partial Applications)和柯里化(Currying)</a> ,还有其他函数式编程模式。</p><p>我不在乎面试者是否知道 “closure” 这个单词或它的专业定义。我只想知道他们是否知道闭包的基本原理。如果不知道，通常代表他们没有很多构建真正 JavaScript 应用的经验。</p><blockquote><p><em>If you can’t answer this question, you’re a junior developer. I don’t care how long you’ve been coding.</em></p></blockquote><blockquote><p>That may sound mean, but it’s not. What I mean is that most competent interviewers will ask you what a closure is, and most of the time, getting the answer wrong will cost you the job. Or if you’re lucky enough to get an offer anyway, it will cost you potentially tens of thousands of dollars per year in pay because you’ll be hired as a junior instead of a senior level developer, regardless of how long you’ve been coding.</p></blockquote><p>快速准备一下：“你能说出两种闭包的通用场景？”</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是绑定函数和引用其周围的状态的组合 <strong>(词法环境 lexical environment)</strong>。换句话说，闭包可以让内部函数访问外部函数的作用域。在 JavaScript 中，每次创建函数时，都会在创建函数时创建闭包。</p><p>使用闭包，只需在另一个函数内定义一个函数并且公开出来。通过返回或传递给另一个函数来公开这个函数。</p><p>内部函数可以访问外部函数作用域的变量，即使外部函数完成返回了。</p><h2 id="使用闭包-例子"><a href="#使用闭包-例子" class="headerlink" title="使用闭包 (例子)"></a>使用闭包 (例子)</h2><p>闭包通常用于对象数据私有化。数据私有是让我们能够面向接口编程而不是实现编程的基础。这是可以帮助我们构建强壮软件的一个重要概念。因为实现细节比接口更容易改变。</p><blockquote><p><em>“Program to an interface, not an implementation.”</em></p></blockquote><blockquote><p><em><a href="http://www.amazon.com/gp/product/B000SEIBB8?ie=UTF8&amp;camp=213733&amp;creative=393177&amp;creativeASIN=B000SEIBB8&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=CSQYBHTUP625XI4T" target="_blank" rel="noopener">Design Patterns: Elements of Reusable Object Oriented Software</a></em></p></blockquote><p>在 JavaScript 中，闭包是用于实现数据私有的主要机制。当你使用闭包实现数据私有时，被封装的数据只能在闭包函数作用域中使用。你无法绕过对象 <strong>被授权的方法(privileged methods)</strong> 在外部访问这些数据。任何在闭包作用域内定义的公开方法都是特权方法。例如：</p><script src="//gist.github.com/6fb9890ce1ffb14bad9f059adc4a2f0d.js?file=data-privacy-example.js"></script><p>在上面的例子中，’.get()’ 方法定义在 <code>getSecret()</code> 方法的作用域内，它可以访问<code>getSecret()</code> 中的任何变量，于是它就是一个被授权的方法。在这个例子中，它可以访问参数 <code>secret</code>。</p><p>对象不是产生数据私有的唯一方法。闭包也可以用于创建有状态函数，其返回值可能受其内部状态影响，e.g.:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secret = <span class="function"><span class="params">msg</span> =&gt;</span> () =&gt; msg;</span><br></pre></td></tr></table></figure><script src="//gist.github.com/b16af817ec53ad8bbb49875aa4795e74.js?file=secret.js"></script><p>在函数式编程中，闭包通常用于偏函数应用和柯里化。为了理解这些，我们需要一些定义：</p><p><strong>应用程序</strong>：一个应用给定参数并产生一个返回值的过程。</p><p><strong>偏函数应用</strong>：一个应用部分参数的函数的过程。并返回一个新函数作为参数。换句话说，应用一个具有多个参数的函数并返回一个较少参数的函数。偏函数应用先使用一个或部分参数在将要返回的函数中，等待返回的函数调用剩余的参数来完成整个应用。</p><p>偏函数应用利用闭包作用域来提前使用部分参数。你可以实现一个通用函数来赋予指定函数部分参数。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">partialApply(targetFunction: <span class="built_in">Function</span>, ...fixedArgs: Any[]) =&gt;</span><br><span class="line">  functionWithFewerParams(...remainingArgs: Any[])</span><br></pre></td></tr></table></figure><p>如果你想进一步了解，请看 <a href="https://github.com/ericelliott/rtype#reading-function-signatures" target="_blank" rel="noopener">Rtype: Reading Function Signatures</a></p><p>利用一个接受任意参数的函数，赋予我们指定的参数。并且返回一个新函数接受剩余的参数。</p><p>这个例子将会帮助你理解。你现在又一个 求两个数的和 的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><p>现在你想要一个 10 加任意数字的函数。我们称它为 <code>add10()</code>。<code>add10(5)</code> 的结果应该是15. <code>partialApply()</code> 函数将会实现它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add10 = partialApply(add, <span class="number">10</span>)</span><br><span class="line">add10(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，’10‘ 作为 <strong>固定参数(fixed parameter)</strong> 通过闭包作用域提前赋予给 <code>add()</code>, 从而我们获得了 <code>add10()</code>。</p><p>让我们来看一下如何实现 <code>partialApply()</code>：<br><br><script src="//gist.github.com/543442825c8519c03e19584daab41bc9.js?file=partial-apply.js"></script></p><p>如你所见，它只是简单地返回一个函数，这个函数通过闭包访问了传给 <code>partialApply()</code> 函数的 fixedArgs 参数。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】精通 JavaScript： 什么是函数式编程（Functional Programming）？</title>
      <link href="/2018/08/24/trans-2/"/>
      <url>/2018/08/24/trans-2/</url>
      <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">Master the JavaScript Interview: What is Functional Programming?</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/1600/1*1OxglOpkZHLITbIKEVCy2g.jpeg" alt="Structure Synth — Orihaus (CC BY 2.0)"></p><blockquote><p>“精通 JavaScript 面试” 是一个系列的文章，旨在帮助面试者准备他们在申请中高级职位时可能遇到的常见问题。这些是我在现实面试中经常提出的问题。</p></blockquote><p>函数式编程已经成为了 JavaScript 世界的一个热门话题。仅仅在几年前，甚至只有很少 JavaScript 开发者知道函数式编程，但是在过去的3年中我看到了大量使用函数式编程思维构建的应用。</p><a id="more"></a><p><strong>函数式编程</strong> （简称 FP）是通过纯函数组合来构建软件，避免<strong>共享状态(shared state)</strong>， <strong>可变数据(mutable data)</strong>，以及<strong>副作用(side-effects)</strong>。函数式编程是<strong>声明式(declarative)</strong>的而不是<strong>命令式(imperative)</strong> 的，应用程序状态通过纯函数而改变。与面向对象编程相比，应用程序的状态和对象的方法是共享和共存的。</p><p>函数式编程是一种<strong>编程范式(programming paradigm)</strong>，意思是它是一种基于一些基本的，确定的原则来思考软件构建的一种方式。编程范式的其他例子有包括面向对象编程和过程编程。</p><p>与命令式和面向对象代码相比，函数式的代码通常更简洁，可预测和易于测试。但是如果你不熟悉函数式编程以及与之相关的常见模式，它看起来更愚钝，而且对于新手来说相关文献也难以理解。</p><p>如果你使用谷歌搜索函数式编程，你很快会发现学术术语的高墙，对于初学者来说会非常令人生畏。函数式编程有一个恐怖的学习曲线。但是如果你已经使用了 JavaScript 一段时间，你很可能在真实编程中是用了很多函数式编程的概念和工具。</p><p><strong><em>Don’t let all the new words scare you away. It’s a lot easier than it sounds.</em></strong></p><p>最困难的部分是关于不熟悉的词汇的思维转变。在你掌握函数式编程的意义之前，你还需要理解下面这些定义：</p><ul><li><p>纯函数</p></li><li><p>函数组合</p></li><li><p>避免共享状态</p></li><li><p>避免可变状态</p></li><li><p>避免副作用</p></li></ul><p>换句话说，如果你想真正理解函数式编程的含义，你必须首先理解这些核心概念。</p><h2 id="纯函数-Pure-Function"><a href="#纯函数-Pure-Function" class="headerlink" title="纯函数 (Pure Function)"></a>纯函数 (Pure Function)</h2><p>纯函数是：</p><ul><li><p>输入相同，输出一定相同</p></li><li><p>没有副作用</p></li></ul><p>纯函数具有很多在函数式编程中非常重要的属性，包括<strong>引用透明</strong> （你可以在不改变程序的定义下替换函数调用及返回值）。更多细节 – <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">“What is a Pure Function?”</a></p><h2 id="函数组合-Function-Composition"><a href="#函数组合-Function-Composition" class="headerlink" title="函数组合 (Function Composition)"></a>函数组合 (Function Composition)</h2><p><strong>函数组合</strong>是组合两个或多个函数以产生新的函数或执行某些计算的程序。例如 <code>f.g</code> 等同于 JavaScript 中的 <code>f(g(x))</code>。理解函数组合是了解如何使用函数式编程构建软件的重要一步。补充学习 – <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">“What is Function Composition?”</a></p><h2 id="共享状态-Shared-State"><a href="#共享状态-Shared-State" class="headerlink" title="共享状态 (Shared State)"></a>共享状态 (Shared State)</h2><p><strong>共享状态</strong> 是存在于共享作用域的任何变量，对象或内存空间，或者是在不同作用域之间传递的一个对象的属性。共享作用域可以是全局或闭包。通常，在面向对象编程中，不同作用域直接通过想另一对象添加属性来进行共享对象。</p><p>例如，在电子游戏中又一个主对象，这个主对象将游戏角色和物品作为属性。函数式编程避免了共享状态，依赖于不可变数据结构或从已有数据计算而得到的新数据。有关软件函数如何处理软件状态的更多详细信息 – <a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10 Tips for Better Redux Architecture”</a></p><p>共享状态的问题在于，为了理解函数的结果，你必须要了解所有函数使用或影响每个共享变量的完整历史记录。</p><p>想象一下，你有一个需要保存的用户对象。<code>saveUser()</code> 是一个向服务器发送请求的 API。当 <code>saveUser()</code> 执行时，用户使用 <code>updateAvatar()</code> 函数更改个人资料图片并触发了另一个 <code>saveUser()</code> 函数。保存时，为了保持与服务器同步或响应其他 API 调用，服务器返回一个用户对象来替换内存中的对象。</p><p>不幸的是，第二个响应在第一个响应之前被接收，所以当第一个（现在是过时的）响应返回时，内存中的旧对象已经被覆盖了图片的对象替换了。这是一个条件竞争的例子–一个与共享状态相关的常见错误。</p><p>另一个与共享状态的常见问题是，更改函数调用顺序可能会导致级联错误，因为作用于共享状态的函数与调用时机有关：</p><script src="//gist.github.com/23f93290914912816211c9041ddd856d.js?file=timing-dependency.js"></script><p>当你避免了共享状态，函数调用的时机和顺序不会改变返回结果。使用纯函数，相同的输入，总能得到相同的输出。这使得函数调用完全独立于其他函数调用，这从根本上简化了修改和重构。一个函数的修改或函数调用的时机不会改变或破坏程序的其他部分。</p><script src="//gist.github.com/a9768374c9084bb3cae6d64b5827024d.js?file=no-timing-dependency.js"></script><p>上面的例子中，我们使用 <code>Object.assign()</code> 并传入一个空对象作为第一个参数来复制 x 的属性而不是直接修改它。在这种情况下，它相当于从头创建了一个新对象。 <code>Object.assign()</code> 是 JavaScript 中复制已存在的属性来创建对象的常用模式而不是使用直接修改，我们在第一个例子中演示了直接修改赋值。</p><p>如果你仔细观察了这个例子中的 <code>console.log()</code> 语句，你应该注意到我已经提到过的事情：函数组合。回想之前提到的，函数组成如下所示： <code>f(g(x))</code> 。我们使用了 <code>x1()</code> 和 <code>x2()</code> 替换了 <code>f()</code> 和 <code>g()</code>。</p><p>如果你改变了组合的顺序，输出会发生改变。操作顺序依然是一个麻烦。 <code>f(g(x))</code> 不总是等同于 <code>g(f(x))</code>，但是函数外部的变量发生了什么是无所谓的–这个是重点。使用非纯函数，除非你知道函数使用或影响的每个变量的完整历史记录，否则无法完全理解函数的作用。</p><p>移除函数调用顺序的依赖，并且消除整个类潜在的错误。</p><h2 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性 (Immutability)"></a>不可变性 (Immutability)</h2><p><strong>不可变(immutable)</strong> 对象指的是一个对象在创建后无法修改。反过来说，一个 <strong>可变(mutable)</strong> 对象指的是一个对象在创建后可以修改。</p><p><strong>不可变性(Immutability)</strong> 是函数式编程的一个核心概念，因为没有她，你的程序中的数据流是有损的。状态历史被丢弃，你的软件会蔓延奇怪的错误。关于不可变性的更多信息 – <a href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd" target="_blank" rel="noopener">“The Dao of Immutability.”</a></p><p>在 JavaScript 中，重要的是不要将 <code>const</code> 和不可变性混淆。<code>const</code> 创建了一个变量和变量名的绑定，在创建后无法重新赋值。<code>const</code> 不是创建了一个不可变对象。你无法修改绑定引用的对象，但可以修改对象的属性，也就是说这个 <code>const</code> 创建的绑定是可变的。</p><p>不可变对象是从根本上无法修改的。你可以深度冻结一个对象是这个值无法修改。JavaScript 有一个方法可以冻结对象的一层：</p><script src="//gist.github.com/e01b161efad12f9615fba55b15c684f7.js?file=frozen-objects.js"></script><p>但是冻结的对象只是表面上的不可变。例如，下面这个对象是可变的：</p><script src="//gist.github.com/18585681ea1079101307fa269ec4716c.js?file=frozen-not-immutable.js"></script><p>如你所见，冻结对象的顶层原始属性不能修改，但任何是对象的属性（包括数组等）仍然可以修改。所以，即使冻结对象也不是不可变的，除非你遍历这个对象数并冻结每个对象属性。</p><p>在许多函数式编程语言中，有一种特殊的不可变数据结构称为 <strong>trie 数据结构</strong>，它们被有效地深度冻结。意味着任何层次的属性都无法修改。</p><p>Tries 使用 <strong>结构共享(structural sharing)</strong> 被复制过的不可变对象的所有部分是共享引用内存位置的，这样可以减少使用内存空间，并且可以显著提高某些操作的性能。</p><p>例如，你可以在对象树的根部标识进行比较。如果标识相同，就不必遍历整个树来检查差异。</p><p>JavaScript 中有几个库利用了 tries，包括 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a> 和 <a href="https://github.com/swannodette/mori" target="_blank" rel="noopener">Mori</a>.</p><p>我已经对两者进行了实验，并且倾向于在需要大量不可变状态的大型项目中使用 Immutable.js 。有关更多信息 – <a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10 Tips for Better Redux Architecture”</a></p><h2 id="副作用-Side-Effects"><a href="#副作用-Side-Effects" class="headerlink" title="副作用 (Side Effects)"></a>副作用 (Side Effects)</h2><p>副作用是除了被调用函数的返回值外还有应用程序状态的更改。副作用包括：</p><ul><li><p>修改了任何外部变量或对象属性（e.g., 全局变量或者在父函数作用域链的变量）</p></li><li><p>控制台日志</p></li><li><p>屏幕输出</p></li><li><p>写入文件</p></li><li><p>写入网络</p></li><li><p>触发任何外部进程</p></li><li><p>调用任何其他函数</p></li></ul><p>函数式编程大多避免了副作用，这使得程序更易理解，也更易测试。</p><p>Haskell 和其他函数式语言经常使用 <strong><a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">monads</a></strong> 来隔离和封装来自纯函数的副作用。</p><p>你现在需要知道的是，具有副作用的操作需要和软件的其他部分隔离。如果将副作用和程序逻辑其余部分分开，你的软件将更容易扩展，重构，调试，测试和维护。</p><p>这就是大部分前端框架鼓励用户将状态和组件渲染分开，松耦合的原因。</p><h2 id="高阶函数的可重用性-Reusability-Through-Higher-Order-Functions"><a href="#高阶函数的可重用性-Reusability-Through-Higher-Order-Functions" class="headerlink" title="高阶函数的可重用性 (Reusability Through Higher Order Functions)"></a>高阶函数的可重用性 (Reusability Through Higher Order Functions)</h2><p>函数式编程倾向于复用一组通用的工具函数来处理数据。面向对象编程倾向于方法和数据共存在对象中。这些方法只能处理专门设计的数据，并且通常只能操作同一实例的数据。</p><p>在函数式编程中，所有类型的数据都是公平的。同一个工具函数 <code>map()</code> 可以处理对象，字符串，数字或其他任何类型的数据，因为它将函数作为处理给定类型数据的一个参数。FP 使用高阶函数作为通用技巧。</p><p>JavaScript 的 <strong>头等函数(First Class Functions)</strong> ,允许将函数作为数据。将函数作为变量，参数或返回值等等。。。</p><p><strong>高阶函数(Height Order Function)</strong>, 将函数作为参数或返回值，或两者都有。高阶函数通常用于：</p><ul><li><p>抽象或隔离动作，结果，或者通过回调，promise，monads 等等来实现异步函数。</p></li><li><p>创建可以处理各种类型数据的工具函数</p></li><li><p>将函数作为参数或创建柯里化函数，目的是复用或函数组合</p></li><li><p>输入一组函数并返回这些函数的组合</p></li></ul><h2 id="容器，函子，列表和流-Containers-Functors-Lists-and-Streams"><a href="#容器，函子，列表和流-Containers-Functors-Lists-and-Streams" class="headerlink" title="容器，函子，列表和流(Containers, Functors, Lists, and Streams)"></a>容器，函子，列表和流(Containers, Functors, Lists, and Streams)</h2><p>函子是可以映射的。换句话说，他是一个拥有使用函数替换其中的值的接口的容器。当你看到函子时，你应该想到“可映射的”。</p><p>之前我们学习了可以处理各种数据类型的工具函数 <code>map()</code>。它提供一种映射操作作为函子 API。<code>map()</code> 使用的流程控制操作利用了这个接口。在 <code>Array.prototype.map()</code> 这种情况下，容器时数组，但是只要支持 mapping API，其他的数据结构也可以作为函子。</p><p>让我们来看看 <code>Array.prototype.map()</code>，它时如何允许你从映射工具中抽象数据类型，使 <code>map()</code> 可用于任何数据类型。我们将创建一个简单的 <code>double()</code> 映射，将传入的值双倍输出。</p><script src="//gist.github.com/3e62d5c301c70a6c29eaaafe15009405.js?file=double-mapping.js"></script><p>如果我们想要在游戏中的点数翻倍，需要怎么做？我们所要做的就是传入 <code>map()</code> 的 <code>double()</code> 函数进行微妙的修改，并且一切正常：</p><script src="//gist.github.com/0238c8e291b2c2c5a2f33d3333c51fb2.js?file=map-custom-data-type.js"></script><p>在函数式编程中，为了操作任意数量的不同数据类型，使用如同函子和高阶函数等的抽象的通用工具函数是一个重要概念。你可以看到类似的概念 – <a href="https://github.com/fantasyland/fantasy-land" target="_blank" rel="noopener">all sorts of different ways</a></p><p><em>“A list expressed over time is a stream.”</em></p><p>现在你需要知道的是，数组和函子不是容器应用中容器和值的唯一概念。例如，数组只是事物列表。随时间改变的列表是流，所以你可以使用相同类型的方法来处理传入事件的流，当你真正开始用 FP 构建软件时，你会看到很多东西。</p><h2 id="声明式-vs-命令式-Declarative-vs-Imperative"><a href="#声明式-vs-命令式-Declarative-vs-Imperative" class="headerlink" title="声明式 vs 命令式(Declarative vs Imperative)"></a>声明式 vs 命令式(Declarative vs Imperative)</h2><p>函数式编程是一种声明式范式，意味着程序逻辑不需要确定流程控制来表达。</p><p><strong>命令式(Imperative)</strong> 程序使用特定步骤来获得需要的结果 – <strong>流程控制(flow control)</strong>：<strong>如何(how)</strong> 去做。</p><p><strong>声明式(Declarative)</strong> 程序抽象流程控制 – <strong>做什么(what)</strong>。抽象做的方式。</p><p>例如，命令式映射传入一个数字数组，返回一个这个数组且其中的值都加倍：</p><script src="//gist.github.com/8b5c98dc2b324ee8cfea451762d07bfe.js?file=imperative-example.js"></script><p>这个声明式映射做了相同的事情，但是使用了 <code>Array.prototype.map()</code> 工具来抽象流程控制，这使你更清楚地表达数据流：</p><script src="//gist.github.com/a3fe04fe9f099cb54492bedea6a33fc1.js?file=declarative-example.js"></script><p>命令式代码经常使用语句。语句是执行某些操作的一段代码。常用语句包括 <code>for</code>， <code>if</code>， <code>switch</code>， <code>throw</code> 等等。</p><p>声明式代码更多依赖于表达式。表达式是一段计算一些值的代码。表达式通常组合函数调用，值和操作来计算得出结果。</p><p>下面都是表达式的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">2</span></span><br><span class="line">doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通常，表达式在代码中作为变量，函数返回值或函数参数。表达式在赋值，返回或者出入之前，需要先计算出它的结果。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>函数式编程的偏好：</p><ul><li><p>纯函数而不是共享状态和副作用</p></li><li><p>不可变性高于可变数据</p></li><li><p>函数组合高于命令式的流程控制</p></li><li><p>很多使用高阶函数处理各种数据类型的通用的，可复用的工具函数而不是只能处理同一对象数据的方法</p></li><li><p>声明式而不是命令式 (做什么，而不是怎么做)</p></li><li><p>表达式而不是语句</p></li><li><p>容器 &amp; 高阶函数优于特定多态(ad-hoc polymorphism)</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】JavaScript 工程师需要知道的十道面试题</title>
      <link href="/2018/08/24/trans-1/"/>
      <url>/2018/08/24/trans-1/</url>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*RPKQq3zYYddwJf9rSeQ4Dg.jpeg" alt="Bruce Lee"></p><blockquote><p>原文：<a href="https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95" target="_blank" rel="noopener">10 Interview Questions Every JavaScript Developer Should Know</a></p></blockquote><h2 id="你能说出两个对-JavaScript-应用程序开发人员很重要的编程范式吗？"><a href="#你能说出两个对-JavaScript-应用程序开发人员很重要的编程范式吗？" class="headerlink" title="你能说出两个对 JavaScript 应用程序开发人员很重要的编程范式吗？"></a>你能说出两个对 JavaScript 应用程序开发人员很重要的编程范式吗？</h2><p>JavaScript 是一个多范式语言，通过 <strong>OOP</strong> （面向对象编程）和 <strong>函数式</strong> 编程使其支持 <strong>命令式/过程式</strong> 编程。JavaScript 支持以原型链继承方式的 OOP。</p><a id="more"></a><h3 id="加分点："><a href="#加分点：" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>原型继承 （或者： 原型， OLOO）</p></li><li><p>函数式编程 （或者： 闭包，头等函数，lambdas）</p></li></ul><h3 id="减分点："><a href="#减分点：" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>不知道编程范式是什么，没有提到基于原型的面向对象或函数式编程</li></ul><h3 id="补充学习："><a href="#补充学习：" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</li><li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</li></ul><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>函数式编程通过组合数学函数来生成程序，并且避免共享状态和可变数据。Lisp （1958年指定） 是最早支持函数式编程的语言之一，并且深受 lambda 演算的启发。至今 Lisp 以及很多衍生语言仍在普遍使用。</p><p>函数式编程是 JavaScript 的一个基本概念（JavaScript 的两大支柱之一）。ES5 JavaScript 添加了一些常用工具方法。</p><h3 id="加分点：-1"><a href="#加分点：-1" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>纯函数/函数纯度</p></li><li><p>避免副作用</p></li><li><p>简单函数组合</p></li><li><p>函数式语言的例子：Lisp，ML，Haskell，Erlang，Clojure，Elm，F Sharp，OCaml 等等。。。</p></li><li><p>提及支持函数式编程的特性：头等函数，高阶函数，函数作为参数/值。</p></li></ul><h3 id="减分点：-1"><a href="#减分点：-1" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>没有提及纯函数/避免副作用</p></li><li><p>不能举出函数式编程语言的例子</p></li><li><p>不知道 JavaScript 作为函数式编程特性</p></li></ul><h3 id="补充学习：-1"><a href="#补充学习：-1" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</p></li><li><p><a href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd" target="_blank" rel="noopener">The Dao of Immutability</a></p></li><li><p><a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea" target="_blank" rel="noopener">Composing Software</a></p></li><li><p><a href="http://haskell.cs.yale.edu/wp-content/uploads/2015/03/HSoM.pdf" target="_blank" rel="noopener">The Haskell School of Music</a></p></li></ul><h2 id="类继承和原型继承之间有什么区别？"><a href="#类继承和原型继承之间有什么区别？" class="headerlink" title="类继承和原型继承之间有什么区别？"></a>类继承和原型继承之间有什么区别？</h2><p><strong>类继承：</strong> 实例继承自类（如蓝图–类的描述），并创建子类关系：层级分类。实例通常对构造函数使用‘new’关键字进行实例化。类继承可以使用 ES6 中的 ‘class’ 关键字声明。</p><p><strong>原型继承：</strong> 实例直接继承于其他对象。实例通常使用工厂函数或 ‘Object.create()’ 函数 进行实例化。实例可以由许多不同的对象组成，也可以方便的选择继承对象。</p><blockquote><p>In JavaScript, prototypal inheritance is simpler &amp;<br>more flexible than class inheritance.</p></blockquote><h3 id="加分点：-2"><a href="#加分点：-2" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>类：创建紧耦合或层级/分类</p></li><li><p>原型：提及拼接继承，原型委托，函数继承，对象组合。</p></li></ul><h3 id="减分点：-2"><a href="#减分点：-2" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>没有提及原型继承和组合优于类继承</li></ul><h3 id="补充学习：-2"><a href="#补充学习：-2" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1 — Prototypal OO</a></p></li><li><p><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">Common Misconceptions About Inheritance in JavaScript</a></p></li></ul><div class="video-container"><iframe src="//player.vimeo.com/video/69255635" frameborder="0" allowfullscreen></iframe></div><h2 id="函数式编程和面向对象编程的优缺点是什么？"><a href="#函数式编程和面向对象编程的优缺点是什么？" class="headerlink" title="函数式编程和面向对象编程的优缺点是什么？"></a>函数式编程和面向对象编程的优缺点是什么？</h2><p><strong>OOP 优点：</strong> 容易理解对象的基本概念，并且易于解释方法调用的含义。OOP 倾向于使用命令式风格而不是声明式风格，它类似于计算机遵循的直接指令集。</p><p><strong>OOP 缺点：</strong> 通常依赖于共享状态。对象和行为通常绑定在同一个实体上，这个实体可以由任意数量的函数随机访问，可能导致诸如竞争条件的不期望的行为。</p><p><strong>FP 优点：</strong> 使用函数范式，程序员避免了共享状态和副作用，从而消除由多个函数竞争统一资源所导致的错误。由于具有像 point-free style 的特性，相比于 OOP 函数式倾向于从根本上简化和易于重新组合以获得更通用的可复用代码。</p><p>FP 也倾向于声明式和指称式，它没有详细说明每一步的操作，而是集中精力在 <strong>做什么</strong> ，让底层函数去处理 <strong>如何做</strong> 。这为重构和性能优化留下了巨大的空间，甚至只需修改很少的代码就可以用更高效的算法替换整个算法。</p><p>利用纯函数的计算可以很容易的扩展到跨多处理器或跨分布式计算集群，而不必担心线程资源冲突，条件竞争等。。。</p><p><strong>FP 缺点：</strong> 过度利用 FP 特性（如 point-free style和大型组合）可能会降低可读性，因为生成的代码通常更抽象，更简洁，不具体。</p><p>与函数式编程相比，更多人熟悉 OO 和命令式编程，因此即使是函数式编程中的常见习惯也会让新团队成员感到困惑。</p><p>FP 比 OOP 有更陡峭的学习曲线，因为 OOP 的流行使得 OOP 的学习材料更易于交流，而 FP 更具学术性和正式性。FP 的概念经常被写成来自 lambda 演算，代数和范畴学所使用的习语和符号，所有这些都需要在这些领域的知识基础。</p><h3 id="加分点：-3"><a href="#加分点：-3" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>提及共享状态的问题，不同事件竞争同一资源等等。。。</p></li><li><p>意识到 FP 能够从根本上简化很多应用</p></li><li><p>意识到不同的学习曲线</p></li><li><p>阐明副作用以及它如何影响程序的可维护性</p></li><li><p>意识到高函数式代码基础可能具有陡峭的学习曲线</p></li><li><p>意识到与同等的 FP 代码基础相比，高 OOP 代码基础会难以修改并且非常脆弱。</p></li><li><p>意识到不可变性对程序状态历史的获取和可塑性产生一个极大提高，允许轻松添加诸如无限撤销/重做，倒带/重放，时间旅行调试等功能。不可变性可以在任意编程范式中实现，但共享状态对象使不可变性在 OOP 中的实现变得复杂。</p></li></ul><h3 id="减分点：-3"><a href="#减分点：-3" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>无法列出任一编程范式的缺点–任何一种范式的人都会遇到一些限制。</li></ul><h3 id="补充学习：-3"><a href="#补充学习：-3" class="headerlink" title="补充学习："></a>补充学习：</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</p></li><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 2</a> – 函数式编程</p></li></ul><h2 id="什么时候类继承是一个合适的选择"><a href="#什么时候类继承是一个合适的选择" class="headerlink" title="什么时候类继承是一个合适的选择"></a>什么时候类继承是一个合适的选择</h2><p>答案是从不，或者几乎从不。一定不能有超过一层的继承。多层类继承是反模式的。多年来我一直在发出这个挑战，我听过的答案都属于几个常见的误解之一。更常见的是，挑战遇见沉默。</p><blockquote><p>“If a feature is sometimes useful<br>and sometimes dangerous<br>and if there is a better option<br>then always use the better option.”<br>~ Douglas Crockford</p></blockquote><h3 id="加分点"><a href="#加分点" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>很少,几乎从不,从不.</p></li><li><p>单一层级有时是可以接受的,一个基于类的框架,例如 React.Component</p></li><li><p>偏爱对象组合高于类继承.</p></li></ul><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习:"></a>补充学习:</h3><ul><li><p><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" target="_blank" rel="noopener">The Two Pillars of JavaScript Part 1</a> – 基于原型的面向对象</p></li><li><p><a href="http://davidwalsh.name/javascript-objects" target="_blank" rel="noopener">JS Objects — Inherited a Mess</a></p></li></ul><h2 id="什么时候原型继承是一个合适的选择"><a href="#什么时候原型继承是一个合适的选择" class="headerlink" title="什么时候原型继承是一个合适的选择"></a>什么时候原型继承是一个合适的选择</h2><p>原型继承有不止一个种类</p><ul><li><p><strong>委托</strong> (i.e.,原型链)</p></li><li><p><strong>拼接</strong> (i.e.,mixins, ’Object.assign()‘)</p></li><li><p><strong>函数化</strong> (不要和函数式编程混淆.用于为私有状态/封装创建闭包的函数)</p></li></ul><p>每种类型的原型继承都有自己的一组用例，但它们在组合方式同样有用，它创建了 <strong>has-a</strong> 或 <strong>uses-a</strong> 或 <strong>can-do</strong> 的关系而不是由类继承创建的 <strong>is-a</strong> 的关系.</p><h3 id="加分点-1"><a href="#加分点-1" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>在模块或函数式编程没有提供明显解决方案的情况下</p></li><li><p>当你需要从多个资源组合对象</p></li><li><p>任何你需要继承的时候</p></li></ul><h3 id="减分点"><a href="#减分点" class="headerlink" title="减分点:"></a>减分点:</h3><ul><li><p>不知道何时使用原型</p></li><li><p>没有意识到 mixins 或 ’Object.assign()‘.</p></li></ul><h3 id="补充学习-1"><a href="#补充学习-1" class="headerlink" title="补充学习:"></a>补充学习:</h3><ul><li><a href="http://chimera.labs.oreilly.com/books/1234000000262/ch03.html#chcsrdou100015eilvj6l9inj" target="_blank" rel="noopener">“Programming JavaScript Applications”: Prototypes section</a></li></ul><h2 id="“优先使用对象组合高于类继承”是什么意思"><a href="#“优先使用对象组合高于类继承”是什么意思" class="headerlink" title="“优先使用对象组合高于类继承”是什么意思?"></a>“优先使用对象组合高于类继承”是什么意思?</h2><p>这是  <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">“Design Patterns: Elements of Reusable Object-Oriented Software”</a> 的引用.这意味着代码复用应该是通过将较小的函数组合到新的对象中来实现,而不是通过类的继承来创建新的分类.</p><p>换句话说,要使用 <strong>can-do</strong>, <strong>has-a</strong>,或 <strong>use-a</strong> 关系而不是 <strong>is-a</strong> 关系.</p><h3 id="加分点-2"><a href="#加分点-2" class="headerlink" title="加分点:"></a>加分点:</h3><ul><li><p>避免类继承</p></li><li><p>避免脆弱的基类问题</p></li><li><p>避免紧耦合</p></li><li><p>避免严格分类（强制 is-a 关系最终会在新的使用方案中出错）</p></li><li><p>避免大猩猩香蕉问题（“你想要的是一个香蕉，得到的是拿着香蕉的大猩猩和整个丛林”）</p></li><li><p>使代码更灵活</p></li></ul><h3 id="减分点：-4"><a href="#减分点：-4" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>没有提到上面的任何问题</p></li><li><p>未能阐明组合和类继承的区别，或组合的优点</p></li></ul><h3 id="补充学习：-4"><a href="#补充学习：-4" class="headerlink" title="补充学习："></a>补充学习：</h3><div class="video-container"><iframe src="//www.youtube.com/embed/wfMtDGfHWpA" frameborder="0" allowfullscreen></iframe></div><blockquote><p>Move Over, ‘class’:<br>Composable Factory Functions Are Here</p><footer><strong>Eric Elliott</strong><cite><a href="https://medium.com/p/77f8911c2fee" target="_blank" rel="noopener">Introducing the Stamp Specification</a></cite></footer></blockquote><h2 id="什么是双向数据绑定和单向数据流，他们有何不同？"><a href="#什么是双向数据绑定和单向数据流，他们有何不同？" class="headerlink" title="什么是双向数据绑定和单向数据流，他们有何不同？"></a>什么是双向数据绑定和单向数据流，他们有何不同？</h2><p>双向数据绑定意味着 UI 和数据模型的动态绑定，当 UI 发生变化，数据模型也会发生变化，反之亦然。</p><p>单向数据流意味着数据模型作为数据来源。改变 UI 会触发消息通知把用户意图发送给数据模型（类似 React 中的 “store”）。只有数据模型才能改变应用状态。结果是数据总是向单一方向流动，能够使代码易于理解。</p><p>单向数据流是确定的，而双向绑定可能产生副作用使其难以跟踪和理解。</p><h3 id="加分点：-4"><a href="#加分点：-4" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>Reac 是单向数据流的新典范，所以提及 Reac 是一个好的信号。 + + + Cycle.js 是另外一个流行的单向数据流实现。</p></li><li><p>Angular 是一种使用双向绑定的流行框架</p></li></ul><h3 id="减分点：-5"><a href="#减分点：-5" class="headerlink" title="减分点："></a>减分点：</h3><ul><li>不知道两者的意思。无法阐明两者的区别</li></ul><h3 id="补充学习：-5"><a href="#补充学习：-5" class="headerlink" title="补充学习："></a>补充学习：</h3><div class="video-container"><iframe src="//www.youtube.com/embed/XxVg_s8xAms" frameborder="0" allowfullscreen></iframe></div><h2 id="一体化和微服务架构的优缺点"><a href="#一体化和微服务架构的优缺点" class="headerlink" title="一体化和微服务架构的优缺点"></a>一体化和微服务架构的优缺点</h2><p>一体化架构意味着你的应用代码是紧密结合的，所有组件协同工作，共享内存空间和资源。</p><p>微服务架构意味着你的应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且它们彼此相互独立，甚至可以在不同机器下运行。</p><p><strong>一体化架构优点：</strong> 一体化架构的主要优势是大多数应用程序有大量的交叉点，例如日志，限速以及审查跟踪和 DOS 保护等安全功能。</p><p>当一切都在同一个应用程序中运行时，这样就很容易讲个组件串联起来。</p><p>还有性能优势，因为共享内存比进程间通信 （IPC） 更快。</p><p><strong>一体化架构缺点：</strong> 一体化架构通常是紧耦合的，应用版本迭代杂糅，使得独立扩展和代码可维护性的隔离服务困难。</p><p>一体化结构也难以理解，因为当你查看特定服务或控制器时，可能存在一些不明显的依赖，副作用以及不可思议的问题。</p><p><strong>微服务架构优点：</strong> 微服务架构通常有更好的组织结构，因为每个部分有自己特定的功能，且不需要关心其他部分的功能。为不同应用服务进行重构和重新配置的解藕服务也更简单。（例如同时提供给网页客户端和开放 API 的服务）</p><p>有于微服务架构的组织方式，它还有性能优势，因为可以隔离热服务并且将其扩展为独立于应用程序的其余部分。</p><p><strong>微服务架构缺点：</strong> 当你构建一个新的微服务架构时，你可能会发现很多在设计时没有预料到的跨组件问题。一体化结构可以轻松地通过共享方式或者中间件来处理跨组件问题。</p><p>在微服务架构中，隔离组件之间通信的开销，封装的组件在另外一个服务层可以让所有路由通过。</p><p>最后，一体化架构也需要外部服务来处理组间通信，但一体化架构可以把这个这个工作成本延迟到项目更加成熟的时候。</p><p>微服务经常部署在它们自己的虚拟机或容器里，导致 VM 竞争的激增。这些任务经常通过容器管理工具自动完成。</p><h3 id="加分点：-5"><a href="#加分点：-5" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>倾向于微服务架构，尽管微服务架构初始成本更高。意识到从长远看微服务性能好易扩展。</p></li><li><p>关于微服务架构和一体化架构的实用性。在构建程序方面，微服务在代码级别相互隔离，一体化在开始时就容易捆绑在一起。微服务的高成本可以延迟到更加成熟的时候。</p></li></ul><h3 id="减分点：-6"><a href="#减分点：-6" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>不知道一体化和微服务之间的差别</p></li><li><p>对微服务架构额外高成本不清楚或一些不切实际的想法</p></li><li><p>对微服务架构， IPC （夸进程通信）和网络通信的额外成本不清楚</p></li><li><p>对微服务架构过于消极，不能明确表达如何通过结偶一体化架构来轻松分割成微服务</p></li><li><p>低估了独立可扩展的微服务架构的优势</p></li></ul><h2 id="什么是异步编程，为什么它在-JavaScript-中很重要？"><a href="#什么是异步编程，为什么它在-JavaScript-中很重要？" class="headerlink" title="什么是异步编程，为什么它在 JavaScript 中很重要？"></a>什么是异步编程，为什么它在 JavaScript 中很重要？</h2><p>同步编程意味着，除了条件语句和函数调用，代码从上到下依次执行，例如网络请求和磁盘 I/O 这样长时间的任务会造成阻塞。</p><p>异步编程意味着引擎运行在时间循环上。当需要阻塞操作时，请求开始后，代码继续运行不需要等待请求结果。当响应准备好，触发中断，导致事件处理运行，控制器在其后执行。通过这种方式，单线程就可以处理并发操作了。</p><p>用户交互本质上是异步的，需要花费大部分时间等待用户输入中断事件循环触发事件回调。</p><p>Node 默认时异步的，这意味着服务方式大致相同，循环等待网络请求，在处理第一个请求的同时接收更多到来的请求。</p><p>异步在 JavaScript 中时非常重要的，因为他非常适合用户交互，并且有利于提高服务器的性能。</p><h3 id="加分点：-6"><a href="#加分点：-6" class="headerlink" title="加分点："></a>加分点：</h3><ul><li><p>知道什么是阻塞，以及性能的意义</p></li><li><p>知道事件回调，以及为什么对用户界面交互很重要</p></li></ul><h3 id="减分点：-7"><a href="#减分点：-7" class="headerlink" title="减分点："></a>减分点：</h3><ul><li><p>不熟悉异步或同步</p></li><li><p>无法表达用户交互和异步对性能的影响</p></li></ul>]]></content>
      
      
    </entry>
    
  
  
</search>
